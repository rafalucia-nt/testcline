(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
        return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
        var refProp = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, maybeKey, getOwner(), debugStack, debugTask);
    }
    function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
    };
    React = {
        react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
        }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
}();
}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}),
"[project]/node_modules/dom-mutator/dist/dom-mutator.esm.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "connectGlobalObserver",
    ()=>connectGlobalObserver,
    "default",
    ()=>__TURBOPACK__default__export__,
    "disconnectGlobalObserver",
    ()=>disconnectGlobalObserver,
    "validAttributeName",
    ()=>validAttributeName
]);
var validAttributeName = /^[a-zA-Z:_][a-zA-Z0-9:_.-]*$/;
var nullController = {
    revert: function revert() {}
};
var elements = /*#__PURE__*/ new Map();
var mutations = /*#__PURE__*/ new Set();
function getObserverInit(attr) {
    return attr === 'html' ? {
        childList: true,
        subtree: true,
        attributes: true,
        characterData: true
    } : {
        childList: false,
        subtree: false,
        attributes: true,
        attributeFilter: [
            attr
        ]
    };
}
function getElementRecord(element) {
    var record = elements.get(element);
    if (!record) {
        record = {
            element: element,
            attributes: {}
        };
        elements.set(element, record);
    }
    return record;
}
function createElementPropertyRecord(el, attr, getCurrentValue, setValue, mutationRunner) {
    var currentValue = getCurrentValue(el);
    var record = {
        isDirty: false,
        originalValue: currentValue,
        virtualValue: currentValue,
        mutations: [],
        el: el,
        _positionTimeout: null,
        observer: new MutationObserver(function() {
            // enact a 1 second timeout that blocks subsequent firing of the
            // observer until the timeout is complete. This will prevent multiple
            // mutations from firing in quick succession, which can cause the
            // mutation to be reverted before the DOM has a chance to update.
            if (attr === 'position' && record._positionTimeout) return;
            else if (attr === 'position') record._positionTimeout = setTimeout(function() {
                record._positionTimeout = null;
            }, 1000);
            var currentValue = getCurrentValue(el);
            if (attr === 'position' && currentValue.parentNode === record.virtualValue.parentNode && currentValue.insertBeforeNode === record.virtualValue.insertBeforeNode) return;
            if (currentValue === record.virtualValue) return;
            record.originalValue = currentValue;
            mutationRunner(record);
        }),
        mutationRunner: mutationRunner,
        setValue: setValue,
        getCurrentValue: getCurrentValue
    };
    if (attr === 'position' && el.parentNode) {
        record.observer.observe(el.parentNode, {
            childList: true,
            subtree: true,
            attributes: false,
            characterData: false
        });
    } else {
        record.observer.observe(el, getObserverInit(attr));
    }
    return record;
}
function queueIfNeeded(val, record) {
    var currentVal = record.getCurrentValue(record.el);
    record.virtualValue = val;
    if (val && typeof val !== 'string') {
        if (!currentVal || val.parentNode !== currentVal.parentNode || val.insertBeforeNode !== currentVal.insertBeforeNode) {
            record.isDirty = true;
            runDOMUpdates();
        }
    } else if (val !== currentVal) {
        record.isDirty = true;
        runDOMUpdates();
    }
}
function htmlMutationRunner(record) {
    var val = record.originalValue;
    record.mutations.forEach(function(m) {
        return val = m.mutate(val);
    });
    queueIfNeeded(getTransformedHTML(val), record);
}
function classMutationRunner(record) {
    var val = new Set(record.originalValue.split(/\s+/).filter(Boolean));
    record.mutations.forEach(function(m) {
        return m.mutate(val);
    });
    queueIfNeeded(Array.from(val).filter(Boolean).join(' '), record);
}
function attrMutationRunner(record) {
    var val = record.originalValue;
    record.mutations.forEach(function(m) {
        return val = m.mutate(val);
    });
    queueIfNeeded(val, record);
}
function _loadDOMNodes(_ref) {
    var parentSelector = _ref.parentSelector, insertBeforeSelector = _ref.insertBeforeSelector;
    var parentNode = document.querySelector(parentSelector);
    if (!parentNode) return null;
    var insertBeforeNode = insertBeforeSelector ? document.querySelector(insertBeforeSelector) : null;
    if (insertBeforeSelector && !insertBeforeNode) return null;
    return {
        parentNode: parentNode,
        insertBeforeNode: insertBeforeNode
    };
}
function positionMutationRunner(record) {
    var val = record.originalValue;
    record.mutations.forEach(function(m) {
        var selectors = m.mutate();
        var newNodes = _loadDOMNodes(selectors);
        val = newNodes || val;
    });
    queueIfNeeded(val, record);
}
var getHTMLValue = function getHTMLValue(el) {
    return el.innerHTML;
};
var setHTMLValue = function setHTMLValue(el, value) {
    return el.innerHTML = value;
};
function getElementHTMLRecord(element) {
    var elementRecord = getElementRecord(element);
    if (!elementRecord.html) {
        elementRecord.html = createElementPropertyRecord(element, 'html', getHTMLValue, setHTMLValue, htmlMutationRunner);
    }
    return elementRecord.html;
}
var getElementPosition = function getElementPosition(el) {
    return {
        parentNode: el.parentElement,
        insertBeforeNode: el.nextElementSibling
    };
};
var setElementPosition = function setElementPosition(el, value) {
    if (value.insertBeforeNode && !value.parentNode.contains(value.insertBeforeNode)) {
        // skip position mutation - insertBeforeNode not a child of parent. happens
        // when mutation observer for indvidual element fires out of order
        return;
    }
    value.parentNode.insertBefore(el, value.insertBeforeNode);
};
function getElementPositionRecord(element) {
    var elementRecord = getElementRecord(element);
    if (!elementRecord.position) {
        elementRecord.position = createElementPropertyRecord(element, 'position', getElementPosition, setElementPosition, positionMutationRunner);
    }
    return elementRecord.position;
}
var setClassValue = function setClassValue(el, val) {
    return val ? el.className = val : el.removeAttribute('class');
};
var getClassValue = function getClassValue(el) {
    return el.className;
};
function getElementClassRecord(el) {
    var elementRecord = getElementRecord(el);
    if (!elementRecord.classes) {
        elementRecord.classes = createElementPropertyRecord(el, 'class', getClassValue, setClassValue, classMutationRunner);
    }
    return elementRecord.classes;
}
var getAttrValue = function getAttrValue(attrName) {
    return function(el) {
        var _el$getAttribute;
        return (_el$getAttribute = el.getAttribute(attrName)) != null ? _el$getAttribute : null;
    };
};
var setAttrValue = function setAttrValue(attrName) {
    return function(el, val) {
        return val !== null ? el.setAttribute(attrName, val) : el.removeAttribute(attrName);
    };
};
function getElementAttributeRecord(el, attr) {
    var elementRecord = getElementRecord(el);
    if (!elementRecord.attributes[attr]) {
        elementRecord.attributes[attr] = createElementPropertyRecord(el, attr, getAttrValue(attr), setAttrValue(attr), attrMutationRunner);
    }
    return elementRecord.attributes[attr];
}
function deleteElementPropertyRecord(el, attr) {
    var element = elements.get(el);
    if (!element) return;
    if (attr === 'html') {
        var _element$html, _element$html$observe;
        (_element$html = element.html) == null ? void 0 : (_element$html$observe = _element$html.observer) == null ? void 0 : _element$html$observe.disconnect();
        delete element.html;
    } else if (attr === 'class') {
        var _element$classes, _element$classes$obse;
        (_element$classes = element.classes) == null ? void 0 : (_element$classes$obse = _element$classes.observer) == null ? void 0 : _element$classes$obse.disconnect();
        delete element.classes;
    } else if (attr === 'position') {
        var _element$position, _element$position$obs;
        (_element$position = element.position) == null ? void 0 : (_element$position$obs = _element$position.observer) == null ? void 0 : _element$position$obs.disconnect();
        delete element.position;
    } else {
        var _element$attributes, _element$attributes$a, _element$attributes$a2;
        (_element$attributes = element.attributes) == null ? void 0 : (_element$attributes$a = _element$attributes[attr]) == null ? void 0 : (_element$attributes$a2 = _element$attributes$a.observer) == null ? void 0 : _element$attributes$a2.disconnect();
        delete element.attributes[attr];
    }
}
var transformContainer;
function getTransformedHTML(html) {
    if (!transformContainer) {
        transformContainer = document.createElement('div');
    }
    transformContainer.innerHTML = html;
    return transformContainer.innerHTML;
}
function setPropertyValue(el, attr, m) {
    if (!m.isDirty) return;
    m.isDirty = false;
    var val = m.virtualValue;
    if (!m.mutations.length) {
        deleteElementPropertyRecord(el, attr);
    }
    m.setValue(el, val);
}
function setValue(m, el) {
    m.html && setPropertyValue(el, 'html', m.html);
    m.classes && setPropertyValue(el, 'class', m.classes);
    m.position && setPropertyValue(el, 'position', m.position);
    Object.keys(m.attributes).forEach(function(attr) {
        setPropertyValue(el, attr, m.attributes[attr]);
    });
}
function runDOMUpdates() {
    elements.forEach(setValue);
} // find or create ElementPropertyRecord, add mutation to it, then run
function startMutating(mutation, element) {
    var record = null;
    if (mutation.kind === 'html') {
        record = getElementHTMLRecord(element);
    } else if (mutation.kind === 'class') {
        record = getElementClassRecord(element);
    } else if (mutation.kind === 'attribute') {
        record = getElementAttributeRecord(element, mutation.attribute);
    } else if (mutation.kind === 'position') {
        record = getElementPositionRecord(element);
    }
    if (!record) return;
    record.mutations.push(mutation);
    record.mutationRunner(record);
} // get (existing) ElementPropertyRecord, remove mutation from it, then run
function stopMutating(mutation, el) {
    var record = null;
    if (mutation.kind === 'html') {
        record = getElementHTMLRecord(el);
    } else if (mutation.kind === 'class') {
        record = getElementClassRecord(el);
    } else if (mutation.kind === 'attribute') {
        record = getElementAttributeRecord(el, mutation.attribute);
    } else if (mutation.kind === 'position') {
        record = getElementPositionRecord(el);
    }
    if (!record) return;
    var index = record.mutations.indexOf(mutation);
    if (index !== -1) record.mutations.splice(index, 1);
    record.mutationRunner(record);
} // maintain list of elements associated with mutation
function refreshElementsSet(mutation) {
    // if a position mutation has already found an element to move, don't move
    // any more elements
    if (mutation.kind === 'position' && mutation.elements.size === 1) return;
    var existingElements = new Set(mutation.elements);
    var matchingElements = document.querySelectorAll(mutation.selector);
    matchingElements.forEach(function(el) {
        if (!existingElements.has(el)) {
            mutation.elements.add(el);
            startMutating(mutation, el);
        }
    });
}
function revertMutation(mutation) {
    mutation.elements.forEach(function(el) {
        return stopMutating(mutation, el);
    });
    mutation.elements.clear();
    mutations["delete"](mutation);
}
function refreshAllElementSets() {
    mutations.forEach(refreshElementsSet);
} // Observer for elements that don't exist in the DOM yet
var observer;
function disconnectGlobalObserver() {
    observer && observer.disconnect();
}
function connectGlobalObserver() {
    if (typeof document === 'undefined') return;
    if (!observer) {
        observer = new MutationObserver(function() {
            refreshAllElementSets();
        });
    }
    refreshAllElementSets();
    observer.observe(document.documentElement, {
        childList: true,
        subtree: true,
        attributes: false,
        characterData: false
    });
} // run on init
connectGlobalObserver();
function newMutation(m) {
    // Not in a browser
    if (typeof document === 'undefined') return nullController; // add to global index of mutations
    mutations.add(m); // run refresh on init to establish list of elements associated w/ mutation
    refreshElementsSet(m);
    return {
        revert: function revert() {
            revertMutation(m);
        }
    };
}
function html(selector, mutate) {
    return newMutation({
        kind: 'html',
        elements: new Set(),
        mutate: mutate,
        selector: selector
    });
}
function position(selector, mutate) {
    return newMutation({
        kind: 'position',
        elements: new Set(),
        mutate: mutate,
        selector: selector
    });
}
function classes(selector, mutate) {
    return newMutation({
        kind: 'class',
        elements: new Set(),
        mutate: mutate,
        selector: selector
    });
}
function attribute(selector, attribute, mutate) {
    if (!validAttributeName.test(attribute)) return nullController;
    if (attribute === 'class' || attribute === 'className') {
        return classes(selector, function(classnames) {
            var mutatedClassnames = mutate(Array.from(classnames).join(' '));
            classnames.clear();
            if (!mutatedClassnames) return;
            mutatedClassnames.split(/\s+/g).filter(Boolean).forEach(function(c) {
                return classnames.add(c);
            });
        });
    }
    return newMutation({
        kind: 'attribute',
        attribute: attribute,
        elements: new Set(),
        mutate: mutate,
        selector: selector
    });
}
function declarative(_ref2) {
    var selector = _ref2.selector, action = _ref2.action, value = _ref2.value, attr = _ref2.attribute, parentSelector = _ref2.parentSelector, insertBeforeSelector = _ref2.insertBeforeSelector;
    if (attr === 'html') {
        if (action === 'append') {
            return html(selector, function(val) {
                return val + (value != null ? value : '');
            });
        } else if (action === 'set') {
            return html(selector, function() {
                return value != null ? value : '';
            });
        }
    } else if (attr === 'class') {
        if (action === 'append') {
            return classes(selector, function(val) {
                if (value) val.add(value);
            });
        } else if (action === 'remove') {
            return classes(selector, function(val) {
                if (value) val["delete"](value);
            });
        } else if (action === 'set') {
            return classes(selector, function(val) {
                val.clear();
                if (value) val.add(value);
            });
        }
    } else if (attr === 'position') {
        if (action === 'set' && parentSelector) {
            return position(selector, function() {
                return {
                    insertBeforeSelector: insertBeforeSelector,
                    parentSelector: parentSelector
                };
            });
        }
    } else {
        if (action === 'append') {
            return attribute(selector, attr, function(val) {
                return val !== null ? val + (value != null ? value : '') : value != null ? value : '';
            });
        } else if (action === 'set') {
            return attribute(selector, attr, function() {
                return value != null ? value : '';
            });
        } else if (action === 'remove') {
            return attribute(selector, attr, function() {
                return null;
            });
        }
    }
    return nullController;
}
var index = {
    html: html,
    classes: classes,
    attribute: attribute,
    position: position,
    declarative: declarative
};
const __TURBOPACK__default__export__ = index;
;
 //# sourceMappingURL=dom-mutator.esm.js.map
}),
"[project]/node_modules/@growthbook/growthbook/dist/esm/util.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "chooseVariation",
    ()=>chooseVariation,
    "decrypt",
    ()=>decrypt,
    "getAutoExperimentChangeType",
    ()=>getAutoExperimentChangeType,
    "getBucketRanges",
    ()=>getBucketRanges,
    "getEqualWeights",
    ()=>getEqualWeights,
    "getPolyfills",
    ()=>getPolyfills,
    "getQueryStringOverride",
    ()=>getQueryStringOverride,
    "getUrlRegExp",
    ()=>getUrlRegExp,
    "hash",
    ()=>hash,
    "inNamespace",
    ()=>inNamespace,
    "inRange",
    ()=>inRange,
    "isIncluded",
    ()=>isIncluded,
    "isURLTargeted",
    ()=>isURLTargeted,
    "loadSDKVersion",
    ()=>loadSDKVersion,
    "mergeQueryStrings",
    ()=>mergeQueryStrings,
    "paddedVersionString",
    ()=>paddedVersionString,
    "promiseTimeout",
    ()=>promiseTimeout,
    "toString",
    ()=>toString
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
const polyfills = {
    fetch: globalThis.fetch ? globalThis.fetch.bind(globalThis) : undefined,
    SubtleCrypto: globalThis.crypto ? globalThis.crypto.subtle : undefined,
    EventSource: globalThis.EventSource
};
function getPolyfills() {
    return polyfills;
}
function hashFnv32a(str) {
    let hval = 0x811c9dc5;
    const l = str.length;
    for(let i = 0; i < l; i++){
        hval ^= str.charCodeAt(i);
        hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
    }
    return hval >>> 0;
}
function hash(seed, value, version) {
    // New unbiased hashing algorithm
    if (version === 2) {
        return hashFnv32a(hashFnv32a(seed + value) + "") % 10000 / 10000;
    }
    // Original biased hashing algorithm (keep for backwards compatibility)
    if (version === 1) {
        return hashFnv32a(value + seed) % 1000 / 1000;
    }
    // Unknown hash version
    return null;
}
function getEqualWeights(n) {
    if (n <= 0) return [];
    return new Array(n).fill(1 / n);
}
function inRange(n, range) {
    return n >= range[0] && n < range[1];
}
function inNamespace(hashValue, namespace) {
    const n = hash("__" + namespace[0], hashValue, 1);
    if (n === null) return false;
    return n >= namespace[1] && n < namespace[2];
}
function chooseVariation(n, ranges) {
    for(let i = 0; i < ranges.length; i++){
        if (inRange(n, ranges[i])) {
            return i;
        }
    }
    return -1;
}
function getUrlRegExp(regexString) {
    try {
        const escaped = regexString.replace(/([^\\])\//g, "$1\\/");
        return new RegExp(escaped);
    } catch (e) {
        console.error(e);
        return undefined;
    }
}
function isURLTargeted(url, targets) {
    if (!targets.length) return false;
    let hasIncludeRules = false;
    let isIncluded = false;
    for(let i = 0; i < targets.length; i++){
        const match = _evalURLTarget(url, targets[i].type, targets[i].pattern);
        if (targets[i].include === false) {
            if (match) return false;
        } else {
            hasIncludeRules = true;
            if (match) isIncluded = true;
        }
    }
    return isIncluded || !hasIncludeRules;
}
function _evalSimpleUrlPart(actual, pattern, isPath) {
    try {
        // Escape special regex characters and change wildcard `_____` to `.*`
        let escaped = pattern.replace(/[*.+?^${}()|[\]\\]/g, "\\$&").replace(/_____/g, ".*");
        if (isPath) {
            // When matching pathname, make leading/trailing slashes optional
            escaped = "\\/?" + escaped.replace(/(^\/|\/$)/g, "") + "\\/?";
        }
        const regex = new RegExp("^" + escaped + "$", "i");
        return regex.test(actual);
    } catch (e) {
        return false;
    }
}
function _evalSimpleUrlTarget(actual, pattern) {
    try {
        // If a protocol is missing, but a host is specified, add `https://` to the front
        // Use "_____" as the wildcard since `*` is not a valid hostname in some browsers
        const expected = new URL(pattern.replace(/^([^:/?]*)\./i, "https://$1.").replace(/\*/g, "_____"), "https://_____");
        // Compare each part of the URL separately
        const comps = [
            [
                actual.host,
                expected.host,
                false
            ],
            [
                actual.pathname,
                expected.pathname,
                true
            ]
        ];
        // We only want to compare hashes if it's explicitly being targeted
        if (expected.hash) {
            comps.push([
                actual.hash,
                expected.hash,
                false
            ]);
        }
        expected.searchParams.forEach((v, k)=>{
            comps.push([
                actual.searchParams.get(k) || "",
                v,
                false
            ]);
        });
        // If any comparisons fail, the whole thing fails
        return !comps.some((data)=>!_evalSimpleUrlPart(data[0], data[1], data[2]));
    } catch (e) {
        return false;
    }
}
function _evalURLTarget(url, type, pattern) {
    try {
        const parsed = new URL(url, "https://_");
        if (type === "regex") {
            const regex = getUrlRegExp(pattern);
            if (!regex) return false;
            return regex.test(parsed.href) || regex.test(parsed.href.substring(parsed.origin.length));
        } else if (type === "simple") {
            return _evalSimpleUrlTarget(parsed, pattern);
        }
        return false;
    } catch (e) {
        return false;
    }
}
function getBucketRanges(numVariations, coverage, weights) {
    coverage = coverage === undefined ? 1 : coverage;
    // Make sure coverage is within bounds
    if (coverage < 0) {
        if ("TURBOPACK compile-time truthy", 1) {
            console.error("Experiment.coverage must be greater than or equal to 0");
        }
        coverage = 0;
    } else if (coverage > 1) {
        if ("TURBOPACK compile-time truthy", 1) {
            console.error("Experiment.coverage must be less than or equal to 1");
        }
        coverage = 1;
    }
    // Default to equal weights if missing or invalid
    const equal = getEqualWeights(numVariations);
    weights = weights || equal;
    if (weights.length !== numVariations) {
        if ("TURBOPACK compile-time truthy", 1) {
            console.error("Experiment.weights array must be the same length as Experiment.variations");
        }
        weights = equal;
    }
    // If weights don't add up to 1 (or close to it), default to equal weights
    const totalWeight = weights.reduce((w, sum)=>sum + w, 0);
    if (totalWeight < 0.99 || totalWeight > 1.01) {
        if ("TURBOPACK compile-time truthy", 1) {
            console.error("Experiment.weights must add up to 1");
        }
        weights = equal;
    }
    // Covert weights to ranges
    let cumulative = 0;
    return weights.map((w)=>{
        const start = cumulative;
        cumulative += w;
        return [
            start,
            start + coverage * w
        ];
    });
}
function getQueryStringOverride(id, url, numVariations) {
    if (!url) {
        return null;
    }
    const search = url.split("?")[1];
    if (!search) {
        return null;
    }
    const match = search.replace(/#.*/, "") // Get rid of anchor
    .split("&") // Split into key/value pairs
    .map((kv)=>kv.split("=", 2)).filter((_ref)=>{
        let [k] = _ref;
        return k === id;
    }) // Look for key that matches the experiment id
    .map((_ref2)=>{
        let [, v] = _ref2;
        return parseInt(v);
    }); // Parse the value into an integer
    if (match.length > 0 && match[0] >= 0 && match[0] < numVariations) return match[0];
    return null;
}
function isIncluded(include) {
    try {
        return include();
    } catch (e) {
        console.error(e);
        return false;
    }
}
const base64ToBuf = (b)=>Uint8Array.from(atob(b), (c)=>c.charCodeAt(0));
async function decrypt(encryptedString, decryptionKey, subtle) {
    decryptionKey = decryptionKey || "";
    subtle = subtle || globalThis.crypto && globalThis.crypto.subtle || polyfills.SubtleCrypto;
    if (!subtle) {
        throw new Error("No SubtleCrypto implementation found");
    }
    try {
        const key = await subtle.importKey("raw", base64ToBuf(decryptionKey), {
            name: "AES-CBC",
            length: 128
        }, true, [
            "encrypt",
            "decrypt"
        ]);
        const [iv, cipherText] = encryptedString.split(".");
        const plainTextBuffer = await subtle.decrypt({
            name: "AES-CBC",
            iv: base64ToBuf(iv)
        }, key, base64ToBuf(cipherText));
        return new TextDecoder().decode(plainTextBuffer);
    } catch (e) {
        throw new Error("Failed to decrypt");
    }
}
function toString(input) {
    if (typeof input === "string") return input;
    return JSON.stringify(input);
}
function paddedVersionString(input) {
    if (typeof input === "number") {
        input = input + "";
    }
    if (!input || typeof input !== "string") {
        input = "0";
    }
    // Remove build info and leading `v` if any
    // Split version into parts (both core version numbers and pre-release tags)
    // "v1.2.3-rc.1+build123" -> ["1","2","3","rc","1"]
    const parts = input.replace(/(^v|\+.*$)/g, "").split(/[-.]/);
    // If it's SemVer without a pre-release, add `~` to the end
    // ["1","0","0"] -> ["1","0","0","~"]
    // "~" is the largest ASCII character, so this will make "1.0.0" greater than "1.0.0-beta" for example
    if (parts.length === 3) {
        parts.push("~");
    }
    // Left pad each numeric part with spaces so string comparisons will work ("9">"10", but " 9"<"10")
    // Then, join back together into a single string
    return parts.map((v)=>v.match(/^[0-9]+$/) ? v.padStart(5, " ") : v).join("-");
}
function loadSDKVersion() {
    let version;
    try {
        // @ts-expect-error right-hand value to be replaced by build with string literal
        version = "1.6.1";
    } catch (e) {
        version = "";
    }
    return version;
}
function mergeQueryStrings(oldUrl, newUrl) {
    let currUrl;
    let redirectUrl;
    try {
        currUrl = new URL(oldUrl);
        redirectUrl = new URL(newUrl);
    } catch (e) {
        console.error("Unable to merge query strings: ".concat(e));
        return newUrl;
    }
    currUrl.searchParams.forEach((value, key)=>{
        // skip  if search param already exists in redirectUrl
        if (redirectUrl.searchParams.has(key)) {
            return;
        }
        redirectUrl.searchParams.set(key, value);
    });
    return redirectUrl.toString();
}
function isObj(x) {
    return typeof x === "object" && x !== null;
}
function getAutoExperimentChangeType(exp) {
    if (exp.urlPatterns && exp.variations.some((variation)=>isObj(variation) && "urlRedirect" in variation)) {
        return "redirect";
    } else if (exp.variations.some((variation)=>isObj(variation) && (variation.domMutations || "js" in variation || "css" in variation))) {
        return "visual";
    }
    return "unknown";
}
async function promiseTimeout(promise, timeout) {
    return new Promise((resolve)=>{
        let resolved = false;
        let timer;
        const finish = (data)=>{
            if (resolved) return;
            resolved = true;
            timer && clearTimeout(timer);
            resolve(data || null);
        };
        if (timeout) {
            timer = setTimeout(()=>finish(), timeout);
        }
        promise.then((data)=>finish(data)).catch(()=>finish());
    });
} //# sourceMappingURL=util.mjs.map
}),
"[project]/node_modules/@growthbook/growthbook/dist/esm/feature-repository.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "clearCache",
    ()=>clearCache,
    "configureCache",
    ()=>configureCache,
    "helpers",
    ()=>helpers,
    "onHidden",
    ()=>onHidden,
    "onVisible",
    ()=>onVisible,
    "refreshFeatures",
    ()=>refreshFeatures,
    "setPolyfills",
    ()=>setPolyfills,
    "startStreaming",
    ()=>startStreaming,
    "unsubscribe",
    ()=>unsubscribe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@growthbook/growthbook/dist/esm/util.mjs [app-client] (ecmascript)");
;
// Config settings
const cacheSettings = {
    // Consider a fetch stale after 1 minute
    staleTTL: 1000 * 60,
    // Max time to keep a fetch in cache (4 hours default)
    maxAge: 1000 * 60 * 60 * 4,
    cacheKey: "gbFeaturesCache",
    backgroundSync: true,
    maxEntries: 10,
    disableIdleStreams: false,
    idleStreamInterval: 20000,
    disableCache: false
};
const polyfills = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPolyfills"])();
const helpers = {
    fetchFeaturesCall: (_ref)=>{
        let { host, clientKey, headers } = _ref;
        return polyfills.fetch("".concat(host, "/api/features/").concat(clientKey), {
            headers
        });
    },
    fetchRemoteEvalCall: (_ref2)=>{
        let { host, clientKey, payload, headers } = _ref2;
        const options = {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                ...headers
            },
            body: JSON.stringify(payload)
        };
        return polyfills.fetch("".concat(host, "/api/eval/").concat(clientKey), options);
    },
    eventSourceCall: (_ref3)=>{
        let { host, clientKey, headers } = _ref3;
        if (headers) {
            return new polyfills.EventSource("".concat(host, "/sub/").concat(clientKey), {
                headers
            });
        }
        return new polyfills.EventSource("".concat(host, "/sub/").concat(clientKey));
    },
    startIdleListener: ()=>{
        let idleTimeout;
        const isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
        if (!isBrowser) return;
        const onVisibilityChange = ()=>{
            if (document.visibilityState === "visible") {
                window.clearTimeout(idleTimeout);
                onVisible();
            } else if (document.visibilityState === "hidden") {
                idleTimeout = window.setTimeout(onHidden, cacheSettings.idleStreamInterval);
            }
        };
        document.addEventListener("visibilitychange", onVisibilityChange);
        return ()=>document.removeEventListener("visibilitychange", onVisibilityChange);
    },
    stopIdleListener: ()=>{
    // No-op, replaced by startIdleListener
    }
};
try {
    if (globalThis.localStorage) {
        polyfills.localStorage = globalThis.localStorage;
    }
} catch (e) {
// Ignore localStorage errors
}
// Global state
const subscribedInstances = new Map();
let cacheInitialized = false;
const cache = new Map();
const activeFetches = new Map();
const streams = new Map();
const supportsSSE = new Set();
function setPolyfills(overrides) {
    Object.assign(polyfills, overrides);
}
function configureCache(overrides) {
    Object.assign(cacheSettings, overrides);
    if (!cacheSettings.backgroundSync) {
        clearAutoRefresh();
    }
}
async function clearCache() {
    cache.clear();
    activeFetches.clear();
    clearAutoRefresh();
    cacheInitialized = false;
    await updatePersistentCache();
}
async function refreshFeatures(_ref4) {
    let { instance, timeout, skipCache, allowStale, backgroundSync } = _ref4;
    if (!backgroundSync) {
        cacheSettings.backgroundSync = false;
    }
    return fetchFeaturesWithCache({
        instance,
        allowStale,
        timeout,
        skipCache
    });
}
// Subscribe a GrowthBook instance to feature changes
function subscribe(instance) {
    const key = getKey(instance);
    const subs = subscribedInstances.get(key) || new Set();
    subs.add(instance);
    subscribedInstances.set(key, subs);
}
function unsubscribe(instance) {
    subscribedInstances.forEach((s)=>s.delete(instance));
}
function onHidden() {
    streams.forEach((channel)=>{
        if (!channel) return;
        channel.state = "idle";
        disableChannel(channel);
    });
}
function onVisible() {
    streams.forEach((channel)=>{
        if (!channel) return;
        if (channel.state !== "idle") return;
        enableChannel(channel);
    });
}
// Private functions
async function updatePersistentCache() {
    try {
        if (!polyfills.localStorage) return;
        await polyfills.localStorage.setItem(cacheSettings.cacheKey, JSON.stringify(Array.from(cache.entries())));
    } catch (e) {
    // Ignore localStorage errors
    }
}
// SWR wrapper for fetching features. May indirectly or directly start SSE streaming.
async function fetchFeaturesWithCache(_ref5) {
    let { instance, allowStale, timeout, skipCache } = _ref5;
    const key = getKey(instance);
    const cacheKey = getCacheKey(instance);
    const now = new Date();
    const minStaleAt = new Date(now.getTime() - cacheSettings.maxAge + cacheSettings.staleTTL);
    await initializeCache();
    const existing = !cacheSettings.disableCache && !skipCache ? cache.get(cacheKey) : undefined;
    if (existing && (allowStale || existing.staleAt > now) && existing.staleAt > minStaleAt) {
        // Restore from cache whether SSE is supported
        if (existing.sse) supportsSSE.add(key);
        // Reload features in the background if stale
        if (existing.staleAt < now) {
            fetchFeatures(instance);
        } else {
            startAutoRefresh(instance);
        }
        return {
            data: existing.data,
            success: true,
            source: "cache"
        };
    } else {
        const res = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["promiseTimeout"])(fetchFeatures(instance), timeout);
        return res || {
            data: null,
            success: false,
            source: "timeout",
            error: new Error("Timeout")
        };
    }
}
function getKey(instance) {
    const [apiHost, clientKey] = instance.getApiInfo();
    return "".concat(apiHost, "||").concat(clientKey);
}
function getCacheKey(instance) {
    const baseKey = getKey(instance);
    if (!("isRemoteEval" in instance) || !instance.isRemoteEval()) return baseKey;
    const attributes = instance.getAttributes();
    const cacheKeyAttributes = instance.getCacheKeyAttributes() || Object.keys(instance.getAttributes());
    const ca = {};
    cacheKeyAttributes.forEach((key)=>{
        ca[key] = attributes[key];
    });
    const fv = instance.getForcedVariations();
    const url = instance.getUrl();
    return "".concat(baseKey, "||").concat(JSON.stringify({
        ca,
        fv,
        url
    }));
}
// Populate cache from localStorage (if available)
async function initializeCache() {
    if (cacheInitialized) return;
    cacheInitialized = true;
    try {
        if (polyfills.localStorage) {
            const value = await polyfills.localStorage.getItem(cacheSettings.cacheKey);
            if (!cacheSettings.disableCache && value) {
                const parsed = JSON.parse(value);
                if (parsed && Array.isArray(parsed)) {
                    parsed.forEach((_ref6)=>{
                        let [key, data] = _ref6;
                        cache.set(key, {
                            ...data,
                            staleAt: new Date(data.staleAt)
                        });
                    });
                }
                cleanupCache();
            }
        }
    } catch (e) {
    // Ignore localStorage errors
    }
    if (!cacheSettings.disableIdleStreams) {
        const cleanupFn = helpers.startIdleListener();
        if (cleanupFn) {
            helpers.stopIdleListener = cleanupFn;
        }
    }
}
// Enforce the maxEntries limit
function cleanupCache() {
    const entriesWithTimestamps = Array.from(cache.entries()).map((_ref7)=>{
        let [key, value] = _ref7;
        return {
            key,
            staleAt: value.staleAt.getTime()
        };
    }).sort((a, b)=>a.staleAt - b.staleAt);
    const entriesToRemoveCount = Math.min(Math.max(0, cache.size - cacheSettings.maxEntries), cache.size);
    for(let i = 0; i < entriesToRemoveCount; i++){
        cache.delete(entriesWithTimestamps[i].key);
    }
}
// Called whenever new features are fetched from the API
function onNewFeatureData(key, cacheKey, data) {
    // If contents haven't changed, ignore the update, extend the stale TTL
    const version = data.dateUpdated || "";
    const staleAt = new Date(Date.now() + cacheSettings.staleTTL);
    const existing = !cacheSettings.disableCache ? cache.get(cacheKey) : undefined;
    if (existing && version && existing.version === version) {
        existing.staleAt = staleAt;
        updatePersistentCache();
        return;
    }
    if (!cacheSettings.disableCache) {
        // Update in-memory cache
        cache.set(cacheKey, {
            data,
            version,
            staleAt,
            sse: supportsSSE.has(key)
        });
        cleanupCache();
    }
    // Update local storage (don't await this, just update asynchronously)
    updatePersistentCache();
    // Update features for all subscribed GrowthBook instances
    const instances = subscribedInstances.get(key);
    instances && instances.forEach((instance)=>refreshInstance(instance, data));
}
async function refreshInstance(instance, data) {
    await instance.setPayload(data || instance.getPayload());
}
// Fetch the features payload from helper function or from in-mem injected payload
async function fetchFeatures(instance) {
    const { apiHost, apiRequestHeaders } = instance.getApiHosts();
    const clientKey = instance.getClientKey();
    const remoteEval = "isRemoteEval" in instance && instance.isRemoteEval();
    const key = getKey(instance);
    const cacheKey = getCacheKey(instance);
    let promise = activeFetches.get(cacheKey);
    if (!promise) {
        const fetcher = remoteEval ? helpers.fetchRemoteEvalCall({
            host: apiHost,
            clientKey,
            payload: {
                attributes: instance.getAttributes(),
                forcedVariations: instance.getForcedVariations(),
                forcedFeatures: Array.from(instance.getForcedFeatures().entries()),
                url: instance.getUrl()
            },
            headers: apiRequestHeaders
        }) : helpers.fetchFeaturesCall({
            host: apiHost,
            clientKey,
            headers: apiRequestHeaders
        });
        // TODO: auto-retry if status code indicates a temporary error
        promise = fetcher.then((res)=>{
            if (!res.ok) {
                throw new Error("HTTP error: ".concat(res.status));
            }
            if (res.headers.get("x-sse-support") === "enabled") {
                supportsSSE.add(key);
            }
            return res.json();
        }).then((data)=>{
            onNewFeatureData(key, cacheKey, data);
            startAutoRefresh(instance);
            activeFetches.delete(cacheKey);
            return {
                data,
                success: true,
                source: "network"
            };
        }).catch((e)=>{
            ("TURBOPACK compile-time value", "development") !== "production" && instance.log("Error fetching features", {
                apiHost,
                clientKey,
                error: e ? e.message : null
            });
            activeFetches.delete(cacheKey);
            return {
                data: null,
                source: "error",
                success: false,
                error: e
            };
        });
        activeFetches.set(cacheKey, promise);
    }
    return promise;
}
// Start SSE streaming, listens to feature payload changes and triggers a refresh or re-fetch
function startAutoRefresh(instance) {
    let forceSSE = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    const key = getKey(instance);
    const cacheKey = getCacheKey(instance);
    const { streamingHost, streamingHostRequestHeaders } = instance.getApiHosts();
    const clientKey = instance.getClientKey();
    if (forceSSE) {
        supportsSSE.add(key);
    }
    if (cacheSettings.backgroundSync && supportsSSE.has(key) && polyfills.EventSource) {
        if (streams.has(key)) return;
        const channel = {
            src: null,
            host: streamingHost,
            clientKey,
            headers: streamingHostRequestHeaders,
            cb: (event)=>{
                try {
                    if (event.type === "features-updated") {
                        const instances = subscribedInstances.get(key);
                        instances && instances.forEach((instance)=>{
                            fetchFeatures(instance);
                        });
                    } else if (event.type === "features") {
                        const json = JSON.parse(event.data);
                        onNewFeatureData(key, cacheKey, json);
                    }
                    // Reset error count on success
                    channel.errors = 0;
                } catch (e) {
                    ("TURBOPACK compile-time value", "development") !== "production" && instance.log("SSE Error", {
                        streamingHost,
                        clientKey,
                        error: e ? e.message : null
                    });
                    onSSEError(channel);
                }
            },
            errors: 0,
            state: "active"
        };
        streams.set(key, channel);
        enableChannel(channel);
    }
}
function onSSEError(channel) {
    if (channel.state === "idle") return;
    channel.errors++;
    if (channel.errors > 3 || channel.src && channel.src.readyState === 2) {
        // exponential backoff after 4 errors, with jitter
        const delay = Math.pow(3, channel.errors - 3) * (1000 + Math.random() * 1000);
        disableChannel(channel);
        setTimeout(()=>{
            if ([
                "idle",
                "active"
            ].includes(channel.state)) return;
            enableChannel(channel);
        }, Math.min(delay, 300000)); // 5 minutes max
    }
}
function disableChannel(channel) {
    if (!channel.src) return;
    channel.src.onopen = null;
    channel.src.onerror = null;
    channel.src.close();
    channel.src = null;
    if (channel.state === "active") {
        channel.state = "disabled";
    }
}
function enableChannel(channel) {
    channel.src = helpers.eventSourceCall({
        host: channel.host,
        clientKey: channel.clientKey,
        headers: channel.headers
    });
    channel.state = "active";
    channel.src.addEventListener("features", channel.cb);
    channel.src.addEventListener("features-updated", channel.cb);
    channel.src.onerror = ()=>onSSEError(channel);
    channel.src.onopen = ()=>{
        channel.errors = 0;
    };
}
function destroyChannel(channel, key) {
    disableChannel(channel);
    streams.delete(key);
}
function clearAutoRefresh() {
    // Clear list of which keys are auto-updated
    supportsSSE.clear();
    // Stop listening for any SSE events
    streams.forEach(destroyChannel);
    // Remove all references to GrowthBook instances
    subscribedInstances.clear();
    // Run the idle stream cleanup function
    helpers.stopIdleListener();
}
function startStreaming(instance, options) {
    if (options.streaming) {
        if (!instance.getClientKey()) {
            throw new Error("Must specify clientKey to enable streaming");
        }
        if (options.payload) {
            startAutoRefresh(instance, true);
        }
        subscribe(instance);
    }
} //# sourceMappingURL=feature-repository.mjs.map
}),
"[project]/node_modules/@growthbook/growthbook/dist/esm/mongrule.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */ __turbopack_context__.s([
    "evalCondition",
    ()=>evalCondition
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@growthbook/growthbook/dist/esm/util.mjs [app-client] (ecmascript)");
;
const _regexCache = {};
function evalCondition(obj, condition, // Must be included for `condition` to correctly evaluate group Operators
savedGroups) {
    savedGroups = savedGroups || {};
    // Condition is an object, keys are either specific operators or object paths
    // values are either arguments for operators or conditions for paths
    for (const [k, v] of Object.entries(condition)){
        switch(k){
            case "$or":
                if (!evalOr(obj, v, savedGroups)) return false;
                break;
            case "$nor":
                if (evalOr(obj, v, savedGroups)) return false;
                break;
            case "$and":
                if (!evalAnd(obj, v, savedGroups)) return false;
                break;
            case "$not":
                if (evalCondition(obj, v, savedGroups)) return false;
                break;
            default:
                if (!evalConditionValue(v, getPath(obj, k), savedGroups)) return false;
        }
    }
    return true;
}
// Return value at dot-separated path of an object
function getPath(obj, path) {
    const parts = path.split(".");
    let current = obj;
    for(let i = 0; i < parts.length; i++){
        if (current && typeof current === "object" && parts[i] in current) {
            current = current[parts[i]];
        } else {
            return null;
        }
    }
    return current;
}
// Transform a regex string into a real RegExp object
function getRegex(regex) {
    if (!_regexCache[regex]) {
        _regexCache[regex] = new RegExp(regex.replace(/([^\\])\//g, "$1\\/"));
    }
    return _regexCache[regex];
}
// Evaluate a single value against a condition
function evalConditionValue(condition, value, savedGroups) {
    // Simple equality comparisons
    if (typeof condition === "string") {
        return value + "" === condition;
    }
    if (typeof condition === "number") {
        return value * 1 === condition;
    }
    if (typeof condition === "boolean") {
        return value !== null && !!value === condition;
    }
    if (condition === null) {
        return value === null;
    }
    if (Array.isArray(condition) || !isOperatorObject(condition)) {
        return JSON.stringify(value) === JSON.stringify(condition);
    }
    // This is a special operator condition and we should evaluate each one separately
    for(const op in condition){
        if (!evalOperatorCondition(op, value, condition[op], savedGroups)) {
            return false;
        }
    }
    return true;
}
// If the object has only keys that start with '$'
function isOperatorObject(obj) {
    const keys = Object.keys(obj);
    return keys.length > 0 && keys.filter((k)=>k[0] === "$").length === keys.length;
}
// Return the data type of a value
function getType(v) {
    if (v === null) return "null";
    if (Array.isArray(v)) return "array";
    const t = typeof v;
    if ([
        "string",
        "number",
        "boolean",
        "object",
        "undefined"
    ].includes(t)) {
        return t;
    }
    return "unknown";
}
// At least one element of actual must match the expected condition/value
function elemMatch(actual, expected, savedGroups) {
    if (!Array.isArray(actual)) return false;
    const check = isOperatorObject(expected) ? (v)=>evalConditionValue(expected, v, savedGroups) : (v)=>evalCondition(v, expected, savedGroups);
    for(let i = 0; i < actual.length; i++){
        if (actual[i] && check(actual[i])) {
            return true;
        }
    }
    return false;
}
function isIn(actual, expected) {
    // Do an intersection if attribute is an array
    if (Array.isArray(actual)) {
        return actual.some((el)=>expected.includes(el));
    }
    return expected.includes(actual);
}
// Evaluate a single operator condition
function evalOperatorCondition(operator, actual, expected, savedGroups) {
    switch(operator){
        case "$veq":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["paddedVersionString"])(actual) === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["paddedVersionString"])(expected);
        case "$vne":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["paddedVersionString"])(actual) !== (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["paddedVersionString"])(expected);
        case "$vgt":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["paddedVersionString"])(actual) > (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["paddedVersionString"])(expected);
        case "$vgte":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["paddedVersionString"])(actual) >= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["paddedVersionString"])(expected);
        case "$vlt":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["paddedVersionString"])(actual) < (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["paddedVersionString"])(expected);
        case "$vlte":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["paddedVersionString"])(actual) <= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["paddedVersionString"])(expected);
        case "$eq":
            return actual === expected;
        case "$ne":
            return actual !== expected;
        case "$lt":
            return actual < expected;
        case "$lte":
            return actual <= expected;
        case "$gt":
            return actual > expected;
        case "$gte":
            return actual >= expected;
        case "$exists":
            // Using `!=` and `==` instead of strict checks so it also matches for undefined
            return expected ? actual != null : actual == null;
        case "$in":
            if (!Array.isArray(expected)) return false;
            return isIn(actual, expected);
        case "$inGroup":
            return isIn(actual, savedGroups[expected] || []);
        case "$notInGroup":
            return !isIn(actual, savedGroups[expected] || []);
        case "$nin":
            if (!Array.isArray(expected)) return false;
            return !isIn(actual, expected);
        case "$not":
            return !evalConditionValue(expected, actual, savedGroups);
        case "$size":
            if (!Array.isArray(actual)) return false;
            return evalConditionValue(expected, actual.length, savedGroups);
        case "$elemMatch":
            return elemMatch(actual, expected, savedGroups);
        case "$all":
            if (!Array.isArray(actual)) return false;
            for(let i = 0; i < expected.length; i++){
                let passed = false;
                for(let j = 0; j < actual.length; j++){
                    if (evalConditionValue(expected[i], actual[j], savedGroups)) {
                        passed = true;
                        break;
                    }
                }
                if (!passed) return false;
            }
            return true;
        case "$regex":
            try {
                return getRegex(expected).test(actual);
            } catch (e) {
                return false;
            }
        case "$type":
            return getType(actual) === expected;
        default:
            console.error("Unknown operator: " + operator);
            return false;
    }
}
// Recursive $or rule
function evalOr(obj, conditions, savedGroups) {
    if (!conditions.length) return true;
    for(let i = 0; i < conditions.length; i++){
        if (evalCondition(obj, conditions[i], savedGroups)) {
            return true;
        }
    }
    return false;
}
// Recursive $and rule
function evalAnd(obj, conditions, savedGroups) {
    for(let i = 0; i < conditions.length; i++){
        if (!evalCondition(obj, conditions[i], savedGroups)) {
            return false;
        }
    }
    return true;
} //# sourceMappingURL=mongrule.mjs.map
}),
"[project]/node_modules/@growthbook/growthbook/dist/esm/core.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EVENT_EXPERIMENT_VIEWED",
    ()=>EVENT_EXPERIMENT_VIEWED,
    "EVENT_FEATURE_EVALUATED",
    ()=>EVENT_FEATURE_EVALUATED,
    "decryptPayload",
    ()=>decryptPayload,
    "evalFeature",
    ()=>evalFeature,
    "getAllStickyBucketAssignmentDocs",
    ()=>getAllStickyBucketAssignmentDocs,
    "getApiHosts",
    ()=>getApiHosts,
    "getExperimentDedupeKey",
    ()=>getExperimentDedupeKey,
    "getExperimentResult",
    ()=>getExperimentResult,
    "getHashAttribute",
    ()=>getHashAttribute,
    "getStickyBucketAttributeKey",
    ()=>getStickyBucketAttributeKey,
    "getStickyBucketAttributes",
    ()=>getStickyBucketAttributes,
    "runExperiment",
    ()=>runExperiment
]);
// non-blocking prerequisite eval failed: break out of parentConditions loop, jump to the next rule
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$mongrule$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@growthbook/growthbook/dist/esm/mongrule.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@growthbook/growthbook/dist/esm/util.mjs [app-client] (ecmascript)");
;
;
const EVENT_FEATURE_EVALUATED = "Feature Evaluated";
const EVENT_EXPERIMENT_VIEWED = "Experiment Viewed";
function getForcedFeatureValues(ctx) {
    // Merge user and global values
    const ret = new Map();
    if (ctx.global.forcedFeatureValues) {
        ctx.global.forcedFeatureValues.forEach((v, k)=>ret.set(k, v));
    }
    if (ctx.user.forcedFeatureValues) {
        ctx.user.forcedFeatureValues.forEach((v, k)=>ret.set(k, v));
    }
    return ret;
}
function getForcedVariations(ctx) {
    // Merge user and global values
    if (ctx.global.forcedVariations && ctx.user.forcedVariations) {
        return {
            ...ctx.global.forcedVariations,
            ...ctx.user.forcedVariations
        };
    } else if (ctx.global.forcedVariations) {
        return ctx.global.forcedVariations;
    } else if (ctx.user.forcedVariations) {
        return ctx.user.forcedVariations;
    } else {
        return {};
    }
}
async function safeCall(fn) {
    try {
        await fn();
    } catch (e) {
    // Do nothing
    }
}
function onExperimentViewed(ctx, experiment, result) {
    // Make sure a tracking callback is only fired once per unique experiment
    if (ctx.user.trackedExperiments) {
        const k = getExperimentDedupeKey(experiment, result);
        if (ctx.user.trackedExperiments.has(k)) {
            return [];
        }
        ctx.user.trackedExperiments.add(k);
    }
    if (ctx.user.enableDevMode && ctx.user.devLogs) {
        ctx.user.devLogs.push({
            experiment,
            result,
            timestamp: Date.now().toString(),
            logType: "experiment"
        });
    }
    const calls = [];
    if (ctx.global.trackingCallback) {
        const cb = ctx.global.trackingCallback;
        calls.push(safeCall(()=>cb(experiment, result, ctx.user)));
    }
    if (ctx.user.trackingCallback) {
        const cb = ctx.user.trackingCallback;
        calls.push(safeCall(()=>cb(experiment, result)));
    }
    if (ctx.global.eventLogger) {
        const cb = ctx.global.eventLogger;
        calls.push(safeCall(()=>cb(EVENT_EXPERIMENT_VIEWED, {
                experimentId: experiment.key,
                variationId: result.key,
                hashAttribute: result.hashAttribute,
                hashValue: result.hashValue
            }, ctx.user)));
    }
    return calls;
}
function onFeatureUsage(ctx, key, ret) {
    // Only track a feature once, unless the assigned value changed
    if (ctx.user.trackedFeatureUsage) {
        const stringifiedValue = JSON.stringify(ret.value);
        if (ctx.user.trackedFeatureUsage[key] === stringifiedValue) return;
        ctx.user.trackedFeatureUsage[key] = stringifiedValue;
        if (ctx.user.enableDevMode && ctx.user.devLogs) {
            ctx.user.devLogs.push({
                featureKey: key,
                result: ret,
                timestamp: Date.now().toString(),
                logType: "feature"
            });
        }
    }
    if (ctx.global.onFeatureUsage) {
        const cb = ctx.global.onFeatureUsage;
        safeCall(()=>cb(key, ret, ctx.user));
    }
    if (ctx.user.onFeatureUsage) {
        const cb = ctx.user.onFeatureUsage;
        safeCall(()=>cb(key, ret));
    }
    if (ctx.global.eventLogger) {
        const cb = ctx.global.eventLogger;
        safeCall(()=>cb(EVENT_FEATURE_EVALUATED, {
                feature: key,
                source: ret.source,
                value: ret.value,
                ruleId: ret.source === "defaultValue" ? "$default" : ret.ruleId || "",
                variationId: ret.experimentResult ? ret.experimentResult.key : ""
            }, ctx.user));
    }
}
function evalFeature(id, ctx) {
    if (ctx.stack.evaluatedFeatures.has(id)) {
        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("evalFeature: circular dependency detected: ".concat(ctx.stack.id, " -> ").concat(id), {
            from: ctx.stack.id,
            to: id
        });
        return getFeatureResult(ctx, id, null, "cyclicPrerequisite");
    }
    ctx.stack.evaluatedFeatures.add(id);
    ctx.stack.id = id;
    // Global override
    const forcedValues = getForcedFeatureValues(ctx);
    if (forcedValues.has(id)) {
        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Global override", {
            id,
            value: forcedValues.get(id)
        });
        return getFeatureResult(ctx, id, forcedValues.get(id), "override");
    }
    // Unknown feature id
    if (!ctx.global.features || !ctx.global.features[id]) {
        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Unknown feature", {
            id
        });
        return getFeatureResult(ctx, id, null, "unknownFeature");
    }
    // Get the feature
    const feature = ctx.global.features[id];
    // Loop through the rules
    if (feature.rules) {
        const evaluatedFeatures = new Set(ctx.stack.evaluatedFeatures);
        rules: for (const rule of feature.rules){
            // If there are prerequisite flag(s), evaluate them
            if (rule.parentConditions) {
                for (const parentCondition of rule.parentConditions){
                    ctx.stack.evaluatedFeatures = new Set(evaluatedFeatures);
                    const parentResult = evalFeature(parentCondition.id, ctx);
                    // break out for cyclic prerequisites
                    if (parentResult.source === "cyclicPrerequisite") {
                        return getFeatureResult(ctx, id, null, "cyclicPrerequisite");
                    }
                    const evalObj = {
                        value: parentResult.value
                    };
                    const evaled = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$mongrule$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["evalCondition"])(evalObj, parentCondition.condition || {});
                    if (!evaled) {
                        // blocking prerequisite eval failed: feature evaluation fails
                        if (parentCondition.gate) {
                            ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Feature blocked by prerequisite", {
                                id,
                                rule
                            });
                            return getFeatureResult(ctx, id, null, "prerequisite");
                        }
                        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip rule because prerequisite evaluation fails", {
                            id,
                            rule
                        });
                        continue rules;
                    }
                }
            }
            // If there are filters for who is included (e.g. namespaces)
            if (rule.filters && isFilteredOut(rule.filters, ctx)) {
                ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip rule because of filters", {
                    id,
                    rule
                });
                continue;
            }
            // Feature value is being forced
            if ("force" in rule) {
                // If it's a conditional rule, skip if the condition doesn't pass
                if (rule.condition && !conditionPasses(rule.condition, ctx)) {
                    ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip rule because of condition ff", {
                        id,
                        rule
                    });
                    continue;
                }
                // If this is a percentage rollout, skip if not included
                if (!isIncludedInRollout(ctx, rule.seed || id, rule.hashAttribute, ctx.user.saveStickyBucketAssignmentDoc && !rule.disableStickyBucketing ? rule.fallbackAttribute : undefined, rule.range, rule.coverage, rule.hashVersion)) {
                    ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip rule because user not included in rollout", {
                        id,
                        rule
                    });
                    continue;
                }
                ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Force value from rule", {
                    id,
                    rule
                });
                // If this was a remotely evaluated experiment, fire the tracking callbacks
                if (rule.tracks) {
                    rule.tracks.forEach((t)=>{
                        const calls = onExperimentViewed(ctx, t.experiment, t.result);
                        if (!calls.length && ctx.global.saveDeferredTrack) {
                            ctx.global.saveDeferredTrack({
                                experiment: t.experiment,
                                result: t.result
                            });
                        }
                    });
                }
                return getFeatureResult(ctx, id, rule.force, "force", rule.id);
            }
            if (!rule.variations) {
                ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip invalid rule", {
                    id,
                    rule
                });
                continue;
            }
            // For experiment rules, run an experiment
            const exp = {
                variations: rule.variations,
                key: rule.key || id
            };
            if ("coverage" in rule) exp.coverage = rule.coverage;
            if (rule.weights) exp.weights = rule.weights;
            if (rule.hashAttribute) exp.hashAttribute = rule.hashAttribute;
            if (rule.fallbackAttribute) exp.fallbackAttribute = rule.fallbackAttribute;
            if (rule.disableStickyBucketing) exp.disableStickyBucketing = rule.disableStickyBucketing;
            if (rule.bucketVersion !== undefined) exp.bucketVersion = rule.bucketVersion;
            if (rule.minBucketVersion !== undefined) exp.minBucketVersion = rule.minBucketVersion;
            if (rule.namespace) exp.namespace = rule.namespace;
            if (rule.meta) exp.meta = rule.meta;
            if (rule.ranges) exp.ranges = rule.ranges;
            if (rule.name) exp.name = rule.name;
            if (rule.phase) exp.phase = rule.phase;
            if (rule.seed) exp.seed = rule.seed;
            if (rule.hashVersion) exp.hashVersion = rule.hashVersion;
            if (rule.filters) exp.filters = rule.filters;
            if (rule.condition) exp.condition = rule.condition;
            // Only return a value if the user is part of the experiment
            const { result } = runExperiment(exp, id, ctx);
            ctx.global.onExperimentEval && ctx.global.onExperimentEval(exp, result);
            if (result.inExperiment && !result.passthrough) {
                return getFeatureResult(ctx, id, result.value, "experiment", rule.id, exp, result);
            }
        }
    }
    ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Use default value", {
        id,
        value: feature.defaultValue
    });
    // Fall back to using the default value
    return getFeatureResult(ctx, id, feature.defaultValue === undefined ? null : feature.defaultValue, "defaultValue");
}
function runExperiment(experiment, featureId, ctx) {
    const key = experiment.key;
    const numVariations = experiment.variations.length;
    // 1. If experiment has less than 2 variations, return immediately
    if (numVariations < 2) {
        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Invalid experiment", {
            id: key
        });
        return {
            result: getExperimentResult(ctx, experiment, -1, false, featureId)
        };
    }
    // 2. If the context is disabled, return immediately
    if (ctx.global.enabled === false || ctx.user.enabled === false) {
        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Context disabled", {
            id: key
        });
        return {
            result: getExperimentResult(ctx, experiment, -1, false, featureId)
        };
    }
    // 2.5. Merge in experiment overrides from the context
    experiment = mergeOverrides(experiment, ctx);
    // 2.6 New, more powerful URL targeting
    if (experiment.urlPatterns && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isURLTargeted"])(ctx.user.url || "", experiment.urlPatterns)) {
        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip because of url targeting", {
            id: key
        });
        return {
            result: getExperimentResult(ctx, experiment, -1, false, featureId)
        };
    }
    // 3. If a variation is forced from a querystring, return the forced variation
    const qsOverride = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getQueryStringOverride"])(key, ctx.user.url || "", numVariations);
    if (qsOverride !== null) {
        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Force via querystring", {
            id: key,
            variation: qsOverride
        });
        return {
            result: getExperimentResult(ctx, experiment, qsOverride, false, featureId)
        };
    }
    // 4. If a variation is forced in the context, return the forced variation
    const forcedVariations = getForcedVariations(ctx);
    if (key in forcedVariations) {
        const variation = forcedVariations[key];
        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Force via dev tools", {
            id: key,
            variation
        });
        return {
            result: getExperimentResult(ctx, experiment, variation, false, featureId)
        };
    }
    // 5. Exclude if a draft experiment or not active
    if (experiment.status === "draft" || experiment.active === false) {
        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip because inactive", {
            id: key
        });
        return {
            result: getExperimentResult(ctx, experiment, -1, false, featureId)
        };
    }
    // 6. Get the hash attribute and return if empty
    const { hashAttribute, hashValue } = getHashAttribute(ctx, experiment.hashAttribute, ctx.user.saveStickyBucketAssignmentDoc && !experiment.disableStickyBucketing ? experiment.fallbackAttribute : undefined);
    if (!hashValue) {
        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip because missing hashAttribute", {
            id: key
        });
        return {
            result: getExperimentResult(ctx, experiment, -1, false, featureId)
        };
    }
    let assigned = -1;
    let foundStickyBucket = false;
    let stickyBucketVersionIsBlocked = false;
    if (ctx.user.saveStickyBucketAssignmentDoc && !experiment.disableStickyBucketing) {
        const { variation, versionIsBlocked } = getStickyBucketVariation({
            ctx,
            expKey: experiment.key,
            expBucketVersion: experiment.bucketVersion,
            expHashAttribute: experiment.hashAttribute,
            expFallbackAttribute: experiment.fallbackAttribute,
            expMinBucketVersion: experiment.minBucketVersion,
            expMeta: experiment.meta
        });
        foundStickyBucket = variation >= 0;
        assigned = variation;
        stickyBucketVersionIsBlocked = !!versionIsBlocked;
    }
    // Some checks are not needed if we already have a sticky bucket
    if (!foundStickyBucket) {
        // 7. Exclude if user is filtered out (used to be called "namespace")
        if (experiment.filters) {
            if (isFilteredOut(experiment.filters, ctx)) {
                ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip because of filters", {
                    id: key
                });
                return {
                    result: getExperimentResult(ctx, experiment, -1, false, featureId)
                };
            }
        } else if (experiment.namespace && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["inNamespace"])(hashValue, experiment.namespace)) {
            ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip because of namespace", {
                id: key
            });
            return {
                result: getExperimentResult(ctx, experiment, -1, false, featureId)
            };
        }
        // 7.5. Exclude if experiment.include returns false or throws
        if (experiment.include && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIncluded"])(experiment.include)) {
            ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip because of include function", {
                id: key
            });
            return {
                result: getExperimentResult(ctx, experiment, -1, false, featureId)
            };
        }
        // 8. Exclude if condition is false
        if (experiment.condition && !conditionPasses(experiment.condition, ctx)) {
            ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip because of condition exp", {
                id: key
            });
            return {
                result: getExperimentResult(ctx, experiment, -1, false, featureId)
            };
        }
        // 8.05. Exclude if prerequisites are not met
        if (experiment.parentConditions) {
            const evaluatedFeatures = new Set(ctx.stack.evaluatedFeatures);
            for (const parentCondition of experiment.parentConditions){
                ctx.stack.evaluatedFeatures = new Set(evaluatedFeatures);
                const parentResult = evalFeature(parentCondition.id, ctx);
                // break out for cyclic prerequisites
                if (parentResult.source === "cyclicPrerequisite") {
                    return {
                        result: getExperimentResult(ctx, experiment, -1, false, featureId)
                    };
                }
                const evalObj = {
                    value: parentResult.value
                };
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$mongrule$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["evalCondition"])(evalObj, parentCondition.condition || {})) {
                    ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip because prerequisite evaluation fails", {
                        id: key
                    });
                    return {
                        result: getExperimentResult(ctx, experiment, -1, false, featureId)
                    };
                }
            }
        }
        // 8.1. Exclude if user is not in a required group
        if (experiment.groups && !hasGroupOverlap(experiment.groups, ctx)) {
            ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip because of groups", {
                id: key
            });
            return {
                result: getExperimentResult(ctx, experiment, -1, false, featureId)
            };
        }
    }
    // 8.2. Old style URL targeting
    if (experiment.url && !urlIsValid(experiment.url, ctx)) {
        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip because of url", {
            id: key
        });
        return {
            result: getExperimentResult(ctx, experiment, -1, false, featureId)
        };
    }
    // 9. Get the variation from the sticky bucket or get bucket ranges and choose variation
    const n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hash"])(experiment.seed || key, hashValue, experiment.hashVersion || 1);
    if (n === null) {
        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip because of invalid hash version", {
            id: key
        });
        return {
            result: getExperimentResult(ctx, experiment, -1, false, featureId)
        };
    }
    if (!foundStickyBucket) {
        const ranges = experiment.ranges || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBucketRanges"])(numVariations, experiment.coverage === undefined ? 1 : experiment.coverage, experiment.weights);
        assigned = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chooseVariation"])(n, ranges);
    }
    // 9.5 Unenroll if any prior sticky buckets are blocked by version
    if (stickyBucketVersionIsBlocked) {
        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip because sticky bucket version is blocked", {
            id: key
        });
        return {
            result: getExperimentResult(ctx, experiment, -1, false, featureId, undefined, true)
        };
    }
    // 10. Return if not in experiment
    if (assigned < 0) {
        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip because of coverage", {
            id: key
        });
        return {
            result: getExperimentResult(ctx, experiment, -1, false, featureId)
        };
    }
    // 11. Experiment has a forced variation
    if ("force" in experiment) {
        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Force variation", {
            id: key,
            variation: experiment.force
        });
        return {
            result: getExperimentResult(ctx, experiment, experiment.force === undefined ? -1 : experiment.force, false, featureId)
        };
    }
    // 12. Exclude if in QA mode
    if (ctx.global.qaMode || ctx.user.qaMode) {
        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip because QA mode", {
            id: key
        });
        return {
            result: getExperimentResult(ctx, experiment, -1, false, featureId)
        };
    }
    // 12.5. Exclude if experiment is stopped
    if (experiment.status === "stopped") {
        ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("Skip because stopped", {
            id: key
        });
        return {
            result: getExperimentResult(ctx, experiment, -1, false, featureId)
        };
    }
    // 13. Build the result object
    const result = getExperimentResult(ctx, experiment, assigned, true, featureId, n, foundStickyBucket);
    // 13.5. Persist sticky bucket
    if (ctx.user.saveStickyBucketAssignmentDoc && !experiment.disableStickyBucketing) {
        const { changed, key: attrKey, doc } = generateStickyBucketAssignmentDoc(ctx, hashAttribute, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(hashValue), {
            [getStickyBucketExperimentKey(experiment.key, experiment.bucketVersion)]: result.key
        });
        if (changed) {
            // update local docs
            ctx.user.stickyBucketAssignmentDocs = ctx.user.stickyBucketAssignmentDocs || {};
            ctx.user.stickyBucketAssignmentDocs[attrKey] = doc;
            // save doc
            ctx.user.saveStickyBucketAssignmentDoc(doc);
        }
    }
    // 14. Fire the tracking callback(s)
    // Store the promise in case we're awaiting it (ex: browser url redirects)
    const trackingCalls = onExperimentViewed(ctx, experiment, result);
    if (trackingCalls.length === 0 && ctx.global.saveDeferredTrack) {
        ctx.global.saveDeferredTrack({
            experiment,
            result
        });
    }
    const trackingCall = !trackingCalls.length ? undefined : trackingCalls.length === 1 ? trackingCalls[0] : Promise.all(trackingCalls).then(()=>{});
    // 14.1 Keep track of completed changeIds
    "changeId" in experiment && experiment.changeId && ctx.global.recordChangeId && ctx.global.recordChangeId(experiment.changeId);
    // 15. Return the result
    ("TURBOPACK compile-time value", "development") !== "production" && ctx.global.log("In experiment", {
        id: key,
        variation: result.variationId
    });
    return {
        result,
        trackingCall
    };
}
function getFeatureResult(ctx, key, value, source, ruleId, experiment, result) {
    const ret = {
        value,
        on: !!value,
        off: !value,
        source,
        ruleId: ruleId || ""
    };
    if (experiment) ret.experiment = experiment;
    if (result) ret.experimentResult = result;
    // Track the usage of this feature in real-time
    if (source !== "override") {
        onFeatureUsage(ctx, key, ret);
    }
    return ret;
}
function getAttributes(ctx) {
    return {
        ...ctx.user.attributes,
        ...ctx.user.attributeOverrides
    };
}
function conditionPasses(condition, ctx) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$mongrule$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["evalCondition"])(getAttributes(ctx), condition, ctx.global.savedGroups || {});
}
function isFilteredOut(filters, ctx) {
    return filters.some((filter)=>{
        const { hashValue } = getHashAttribute(ctx, filter.attribute);
        if (!hashValue) return true;
        const n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hash"])(filter.seed, hashValue, filter.hashVersion || 2);
        if (n === null) return true;
        return !filter.ranges.some((r)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["inRange"])(n, r));
    });
}
function isIncludedInRollout(ctx, seed, hashAttribute, fallbackAttribute, range, coverage, hashVersion) {
    if (!range && coverage === undefined) return true;
    if (!range && coverage === 0) return false;
    const { hashValue } = getHashAttribute(ctx, hashAttribute, fallbackAttribute);
    if (!hashValue) {
        return false;
    }
    const n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hash"])(seed, hashValue, hashVersion || 1);
    if (n === null) return false;
    return range ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["inRange"])(n, range) : coverage !== undefined ? n <= coverage : true;
}
function getExperimentResult(ctx, experiment, variationIndex, hashUsed, featureId, bucket, stickyBucketUsed) {
    let inExperiment = true;
    // If assigned variation is not valid, use the baseline and mark the user as not in the experiment
    if (variationIndex < 0 || variationIndex >= experiment.variations.length) {
        variationIndex = 0;
        inExperiment = false;
    }
    const { hashAttribute, hashValue } = getHashAttribute(ctx, experiment.hashAttribute, ctx.user.saveStickyBucketAssignmentDoc && !experiment.disableStickyBucketing ? experiment.fallbackAttribute : undefined);
    const meta = experiment.meta ? experiment.meta[variationIndex] : {};
    const res = {
        key: meta.key || "" + variationIndex,
        featureId,
        inExperiment,
        hashUsed,
        variationId: variationIndex,
        value: experiment.variations[variationIndex],
        hashAttribute,
        hashValue,
        stickyBucketUsed: !!stickyBucketUsed
    };
    if (meta.name) res.name = meta.name;
    if (bucket !== undefined) res.bucket = bucket;
    if (meta.passthrough) res.passthrough = meta.passthrough;
    return res;
}
function mergeOverrides(experiment, ctx) {
    const key = experiment.key;
    const o = ctx.global.overrides;
    if (o && o[key]) {
        experiment = Object.assign({}, experiment, o[key]);
        if (typeof experiment.url === "string") {
            experiment.url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUrlRegExp"])(// eslint-disable-next-line
            experiment.url);
        }
    }
    return experiment;
}
function getHashAttribute(ctx, attr, fallback) {
    let hashAttribute = attr || "id";
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let hashValue = "";
    const attributes = getAttributes(ctx);
    if (attributes[hashAttribute]) {
        hashValue = attributes[hashAttribute];
    }
    // if no match, try fallback
    if (!hashValue && fallback) {
        if (attributes[fallback]) {
            hashValue = attributes[fallback];
        }
        if (hashValue) {
            hashAttribute = fallback;
        }
    }
    return {
        hashAttribute,
        hashValue
    };
}
function urlIsValid(urlRegex, ctx) {
    const url = ctx.user.url;
    if (!url) return false;
    const pathOnly = url.replace(/^https?:\/\//, "").replace(/^[^/]*\//, "/");
    if (urlRegex.test(url)) return true;
    if (urlRegex.test(pathOnly)) return true;
    return false;
}
function hasGroupOverlap(expGroups, ctx) {
    const groups = ctx.global.groups || {};
    for(let i = 0; i < expGroups.length; i++){
        if (groups[expGroups[i]]) return true;
    }
    return false;
}
function getStickyBucketVariation(_ref) {
    let { ctx, expKey, expBucketVersion, expHashAttribute, expFallbackAttribute, expMinBucketVersion, expMeta } = _ref;
    expBucketVersion = expBucketVersion || 0;
    expMinBucketVersion = expMinBucketVersion || 0;
    expHashAttribute = expHashAttribute || "id";
    expMeta = expMeta || [];
    const id = getStickyBucketExperimentKey(expKey, expBucketVersion);
    const assignments = getStickyBucketAssignments(ctx, expHashAttribute, expFallbackAttribute);
    // users with any blocked bucket version (0 to minExperimentBucketVersion) are excluded from the test
    if (expMinBucketVersion > 0) {
        for(let i = 0; i <= expMinBucketVersion; i++){
            const blockedKey = getStickyBucketExperimentKey(expKey, i);
            if (assignments[blockedKey] !== undefined) {
                return {
                    variation: -1,
                    versionIsBlocked: true
                };
            }
        }
    }
    const variationKey = assignments[id];
    if (variationKey === undefined) // no assignment found
    return {
        variation: -1
    };
    const variation = expMeta.findIndex((m)=>m.key === variationKey);
    if (variation < 0) // invalid assignment, treat as "no assignment found"
    return {
        variation: -1
    };
    return {
        variation
    };
}
function getStickyBucketExperimentKey(experimentKey, experimentBucketVersion) {
    experimentBucketVersion = experimentBucketVersion || 0;
    return "".concat(experimentKey, "__").concat(experimentBucketVersion);
}
function getStickyBucketAttributeKey(attributeName, attributeValue) {
    return "".concat(attributeName, "||").concat(attributeValue);
}
function getStickyBucketAssignments(ctx, expHashAttribute, expFallbackAttribute) {
    if (!ctx.user.stickyBucketAssignmentDocs) return {};
    const { hashAttribute, hashValue } = getHashAttribute(ctx, expHashAttribute);
    const hashKey = getStickyBucketAttributeKey(hashAttribute, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(hashValue));
    const { hashAttribute: fallbackAttribute, hashValue: fallbackValue } = getHashAttribute(ctx, expFallbackAttribute);
    const fallbackKey = fallbackValue ? getStickyBucketAttributeKey(fallbackAttribute, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(fallbackValue)) : null;
    const assignments = {};
    if (fallbackKey && ctx.user.stickyBucketAssignmentDocs[fallbackKey]) {
        Object.assign(assignments, ctx.user.stickyBucketAssignmentDocs[fallbackKey].assignments || {});
    }
    if (ctx.user.stickyBucketAssignmentDocs[hashKey]) {
        Object.assign(assignments, ctx.user.stickyBucketAssignmentDocs[hashKey].assignments || {});
    }
    return assignments;
}
function generateStickyBucketAssignmentDoc(ctx, attributeName, attributeValue, assignments) {
    const key = getStickyBucketAttributeKey(attributeName, attributeValue);
    const existingAssignments = ctx.user.stickyBucketAssignmentDocs && ctx.user.stickyBucketAssignmentDocs[key] ? ctx.user.stickyBucketAssignmentDocs[key].assignments || {} : {};
    const newAssignments = {
        ...existingAssignments,
        ...assignments
    };
    const changed = JSON.stringify(existingAssignments) !== JSON.stringify(newAssignments);
    return {
        key,
        doc: {
            attributeName,
            attributeValue,
            assignments: newAssignments
        },
        changed
    };
}
function deriveStickyBucketIdentifierAttributes(ctx, data) {
    const attributes = new Set();
    const features = data && data.features ? data.features : ctx.global.features || {};
    const experiments = data && data.experiments ? data.experiments : ctx.global.experiments || [];
    Object.keys(features).forEach((id)=>{
        const feature = features[id];
        if (feature.rules) {
            for (const rule of feature.rules){
                if (rule.variations) {
                    attributes.add(rule.hashAttribute || "id");
                    if (rule.fallbackAttribute) {
                        attributes.add(rule.fallbackAttribute);
                    }
                }
            }
        }
    });
    experiments.map((experiment)=>{
        attributes.add(experiment.hashAttribute || "id");
        if (experiment.fallbackAttribute) {
            attributes.add(experiment.fallbackAttribute);
        }
    });
    return Array.from(attributes);
}
async function getAllStickyBucketAssignmentDocs(ctx, stickyBucketService, data) {
    const attributes = getStickyBucketAttributes(ctx, data);
    return stickyBucketService.getAllAssignments(attributes);
}
function getStickyBucketAttributes(ctx, data) {
    const attributes = {};
    const stickyBucketIdentifierAttributes = deriveStickyBucketIdentifierAttributes(ctx, data);
    stickyBucketIdentifierAttributes.forEach((attr)=>{
        const { hashValue } = getHashAttribute(ctx, attr);
        attributes[attr] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(hashValue);
    });
    return attributes;
}
async function decryptPayload(data, decryptionKey, subtle) {
    data = {
        ...data
    };
    if (data.encryptedFeatures) {
        try {
            data.features = JSON.parse(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decrypt"])(data.encryptedFeatures, decryptionKey, subtle));
        } catch (e) {
            console.error(e);
        }
        delete data.encryptedFeatures;
    }
    if (data.encryptedExperiments) {
        try {
            data.experiments = JSON.parse(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decrypt"])(data.encryptedExperiments, decryptionKey, subtle));
        } catch (e) {
            console.error(e);
        }
        delete data.encryptedExperiments;
    }
    if (data.encryptedSavedGroups) {
        try {
            data.savedGroups = JSON.parse(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decrypt"])(data.encryptedSavedGroups, decryptionKey, subtle));
        } catch (e) {
            console.error(e);
        }
        delete data.encryptedSavedGroups;
    }
    return data;
}
function getApiHosts(options) {
    const defaultHost = options.apiHost || "https://cdn.growthbook.io";
    return {
        apiHost: defaultHost.replace(/\/*$/, ""),
        streamingHost: (options.streamingHost || defaultHost).replace(/\/*$/, ""),
        apiRequestHeaders: options.apiHostRequestHeaders,
        streamingHostRequestHeaders: options.streamingHostRequestHeaders
    };
}
function getExperimentDedupeKey(experiment, result) {
    return result.hashAttribute + result.hashValue + experiment.key + result.variationId;
} //# sourceMappingURL=core.mjs.map
}),
"[project]/node_modules/@growthbook/growthbook/dist/esm/GrowthBook.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GrowthBook",
    ()=>GrowthBook,
    "prefetchPayload",
    ()=>prefetchPayload
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dom$2d$mutator$2f$dist$2f$dom$2d$mutator$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dom-mutator/dist/dom-mutator.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@growthbook/growthbook/dist/esm/util.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$feature$2d$repository$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@growthbook/growthbook/dist/esm/feature-repository.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@growthbook/growthbook/dist/esm/core.mjs [app-client] (ecmascript)");
;
;
;
;
const isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
const SDK_VERSION = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["loadSDKVersion"])();
class GrowthBook {
    async setPayload(payload) {
        this._payload = payload;
        const data = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decryptPayload"])(payload, this._options.decryptionKey);
        this._decryptedPayload = data;
        await this.refreshStickyBuckets(data);
        if (data.features) {
            this._options.features = data.features;
        }
        if (data.savedGroups) {
            this._options.savedGroups = data.savedGroups;
        }
        if (data.experiments) {
            this._options.experiments = data.experiments;
            this._updateAllAutoExperiments();
        }
        this.ready = true;
        this._render();
    }
    initSync(options) {
        this._initialized = true;
        const payload = options.payload;
        if (payload.encryptedExperiments || payload.encryptedFeatures) {
            throw new Error("initSync does not support encrypted payloads");
        }
        if (this._options.stickyBucketService && !this._options.stickyBucketAssignmentDocs) {
            this._options.stickyBucketAssignmentDocs = this.generateStickyBucketAssignmentDocsSync(this._options.stickyBucketService, payload);
        }
        this._payload = payload;
        this._decryptedPayload = payload;
        if (payload.features) {
            this._options.features = payload.features;
        }
        if (payload.experiments) {
            this._options.experiments = payload.experiments;
            this._updateAllAutoExperiments();
        }
        this.ready = true;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$feature$2d$repository$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["startStreaming"])(this, options);
        return this;
    }
    async init(options) {
        this._initialized = true;
        options = options || {};
        if (options.cacheSettings) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$feature$2d$repository$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["configureCache"])(options.cacheSettings);
        }
        if (options.payload) {
            await this.setPayload(options.payload);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$feature$2d$repository$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["startStreaming"])(this, options);
            return {
                success: true,
                source: "init"
            };
        } else {
            const { data, ...res } = await this._refresh({
                ...options,
                allowStale: true
            });
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$feature$2d$repository$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["startStreaming"])(this, options);
            await this.setPayload(data || {});
            return res;
        }
    }
    /** @deprecated Use {@link init} */ async loadFeatures(options) {
        options = options || {};
        var _this__options_backgroundSync;
        await this.init({
            skipCache: options.skipCache,
            timeout: options.timeout,
            streaming: ((_this__options_backgroundSync = this._options.backgroundSync) !== null && _this__options_backgroundSync !== void 0 ? _this__options_backgroundSync : true) && (options.autoRefresh || this._options.subscribeToChanges)
        });
    }
    async refreshFeatures(options) {
        const res = await this._refresh({
            ...options || {},
            allowStale: false
        });
        if (res.data) {
            await this.setPayload(res.data);
        }
    }
    getApiInfo() {
        return [
            this.getApiHosts().apiHost,
            this.getClientKey()
        ];
    }
    getApiHosts() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getApiHosts"])(this._options);
    }
    getClientKey() {
        return this._options.clientKey || "";
    }
    getPayload() {
        return this._payload || {
            features: this.getFeatures(),
            experiments: this.getExperiments()
        };
    }
    getDecryptedPayload() {
        return this._decryptedPayload || this.getPayload();
    }
    isRemoteEval() {
        return this._options.remoteEval || false;
    }
    getCacheKeyAttributes() {
        return this._options.cacheKeyAttributes;
    }
    async _refresh(_ref) {
        let { timeout, skipCache, allowStale, streaming } = _ref;
        if (!this._options.clientKey) {
            throw new Error("Missing clientKey");
        }
        var _ref1;
        // Trigger refresh in feature repository
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$feature$2d$repository$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["refreshFeatures"])({
            instance: this,
            timeout,
            skipCache: skipCache || this._options.disableCache,
            allowStale,
            backgroundSync: (_ref1 = streaming !== null && streaming !== void 0 ? streaming : this._options.backgroundSync) !== null && _ref1 !== void 0 ? _ref1 : true
        });
    }
    _render() {
        if (this._renderer) {
            try {
                this._renderer();
            } catch (e) {
                console.error("Failed to render", e);
            }
        }
    }
    /** @deprecated Use {@link setPayload} */ setFeatures(features) {
        this._options.features = features;
        this.ready = true;
        this._render();
    }
    /** @deprecated Use {@link setPayload} */ async setEncryptedFeatures(encryptedString, decryptionKey, subtle) {
        const featuresJSON = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decrypt"])(encryptedString, decryptionKey || this._options.decryptionKey, subtle);
        this.setFeatures(JSON.parse(featuresJSON));
    }
    /** @deprecated Use {@link setPayload} */ setExperiments(experiments) {
        this._options.experiments = experiments;
        this.ready = true;
        this._updateAllAutoExperiments();
    }
    /** @deprecated Use {@link setPayload} */ async setEncryptedExperiments(encryptedString, decryptionKey, subtle) {
        const experimentsJSON = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decrypt"])(encryptedString, decryptionKey || this._options.decryptionKey, subtle);
        this.setExperiments(JSON.parse(experimentsJSON));
    }
    async setAttributes(attributes) {
        this._options.attributes = attributes;
        if (this._options.stickyBucketService) {
            await this.refreshStickyBuckets();
        }
        if (this._options.remoteEval) {
            await this._refreshForRemoteEval();
            return;
        }
        this._render();
        this._updateAllAutoExperiments();
    }
    async updateAttributes(attributes) {
        return this.setAttributes({
            ...this._options.attributes,
            ...attributes
        });
    }
    async setAttributeOverrides(overrides) {
        this._options.attributeOverrides = overrides;
        if (this._options.stickyBucketService) {
            await this.refreshStickyBuckets();
        }
        if (this._options.remoteEval) {
            await this._refreshForRemoteEval();
            return;
        }
        this._render();
        this._updateAllAutoExperiments();
    }
    async setForcedVariations(vars) {
        this._options.forcedVariations = vars || {};
        if (this._options.remoteEval) {
            await this._refreshForRemoteEval();
            return;
        }
        this._render();
        this._updateAllAutoExperiments();
    }
    // eslint-disable-next-line
    setForcedFeatures(map) {
        this._options.forcedFeatureValues = map;
        this._render();
    }
    async setURL(url) {
        if (url === this._options.url) return;
        this._options.url = url;
        this._redirectedUrl = "";
        if (this._options.remoteEval) {
            await this._refreshForRemoteEval();
            this._updateAllAutoExperiments(true);
            return;
        }
        this._updateAllAutoExperiments(true);
    }
    getAttributes() {
        return {
            ...this._options.attributes,
            ...this._options.attributeOverrides
        };
    }
    getForcedVariations() {
        return this._options.forcedVariations || {};
    }
    getForcedFeatures() {
        // eslint-disable-next-line
        return this._options.forcedFeatureValues || new Map();
    }
    getStickyBucketAssignmentDocs() {
        return this._options.stickyBucketAssignmentDocs || {};
    }
    getUrl() {
        return this._options.url || "";
    }
    getFeatures() {
        return this._options.features || {};
    }
    getExperiments() {
        return this._options.experiments || [];
    }
    getCompletedChangeIds() {
        return Array.from(this._completedChangeIds);
    }
    subscribe(cb) {
        this._subscriptions.add(cb);
        return ()=>{
            this._subscriptions.delete(cb);
        };
    }
    async _refreshForRemoteEval() {
        if (!this._options.remoteEval) return;
        if (!this._initialized) return;
        const res = await this._refresh({
            allowStale: false
        });
        if (res.data) {
            await this.setPayload(res.data);
        }
    }
    getAllResults() {
        return new Map(this._assigned);
    }
    onDestroy(cb) {
        this._destroyCallbacks.push(cb);
    }
    isDestroyed() {
        return !!this._destroyed;
    }
    destroy() {
        this._destroyed = true;
        // Custom callbacks
        // Do this first in case it needs access to the below data that is cleared
        this._destroyCallbacks.forEach((cb)=>{
            try {
                cb();
            } catch (e) {
                console.error(e);
            }
        });
        // Release references to save memory
        this._subscriptions.clear();
        this._assigned.clear();
        this._trackedExperiments.clear();
        this._completedChangeIds.clear();
        this._deferredTrackingCalls.clear();
        this._trackedFeatures = {};
        this._destroyCallbacks = [];
        this._payload = undefined;
        this._saveStickyBucketAssignmentDoc = undefined;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$feature$2d$repository$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsubscribe"])(this);
        this.logs = [];
        if (isBrowser && window._growthbook === this) {
            delete window._growthbook;
        }
        // Undo any active auto experiments
        this._activeAutoExperiments.forEach((exp)=>{
            exp.undo();
        });
        this._activeAutoExperiments.clear();
        this._triggeredExpKeys.clear();
    }
    setRenderer(renderer) {
        this._renderer = renderer;
    }
    forceVariation(key, variation) {
        this._options.forcedVariations = this._options.forcedVariations || {};
        this._options.forcedVariations[key] = variation;
        if (this._options.remoteEval) {
            this._refreshForRemoteEval();
            return;
        }
        this._updateAllAutoExperiments();
        this._render();
    }
    run(experiment) {
        const { result } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["runExperiment"])(experiment, null, this._getEvalContext());
        this._fireSubscriptions(experiment, result);
        return result;
    }
    triggerExperiment(key) {
        this._triggeredExpKeys.add(key);
        if (!this._options.experiments) return null;
        const experiments = this._options.experiments.filter((exp)=>exp.key === key);
        return experiments.map((exp)=>{
            return this._runAutoExperiment(exp);
        }).filter((res)=>res !== null);
    }
    triggerAutoExperiments() {
        this._autoExperimentsAllowed = true;
        this._updateAllAutoExperiments(true);
    }
    _getEvalContext() {
        return {
            user: this._getUserContext(),
            global: this._getGlobalContext(),
            stack: {
                evaluatedFeatures: new Set()
            }
        };
    }
    _getUserContext() {
        return {
            attributes: this._options.user ? {
                ...this._options.user,
                ...this._options.attributes
            } : this._options.attributes,
            enableDevMode: this._options.enableDevMode,
            blockedChangeIds: this._options.blockedChangeIds,
            stickyBucketAssignmentDocs: this._options.stickyBucketAssignmentDocs,
            url: this._getContextUrl(),
            forcedVariations: this._options.forcedVariations,
            forcedFeatureValues: this._options.forcedFeatureValues,
            attributeOverrides: this._options.attributeOverrides,
            saveStickyBucketAssignmentDoc: this._saveStickyBucketAssignmentDoc,
            trackingCallback: this._options.trackingCallback,
            onFeatureUsage: this._options.onFeatureUsage,
            devLogs: this.logs,
            trackedExperiments: this._trackedExperiments,
            trackedFeatureUsage: this._trackedFeatures
        };
    }
    _getGlobalContext() {
        return {
            features: this._options.features,
            experiments: this._options.experiments,
            log: this.log,
            enabled: this._options.enabled,
            qaMode: this._options.qaMode,
            savedGroups: this._options.savedGroups,
            groups: this._options.groups,
            overrides: this._options.overrides,
            onExperimentEval: this._subscriptions.size > 0 ? this._fireSubscriptions : undefined,
            recordChangeId: this._recordChangedId,
            saveDeferredTrack: this._saveDeferredTrack,
            eventLogger: this._options.eventLogger
        };
    }
    _runAutoExperiment(experiment, forceRerun) {
        const existing = this._activeAutoExperiments.get(experiment);
        // If this is a manual experiment and it's not already running, skip
        if (experiment.manual && !this._triggeredExpKeys.has(experiment.key) && !existing) return null;
        // Check if this particular experiment is blocked by options settings
        // For example, if all visualEditor experiments are disabled
        const isBlocked = this._isAutoExperimentBlockedByContext(experiment);
        if (isBlocked) {
            ("TURBOPACK compile-time value", "development") !== "production" && this.log("Auto experiment blocked", {
                id: experiment.key
            });
        }
        let result;
        let trackingCall;
        // Run the experiment (if blocked exclude)
        if (isBlocked) {
            result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getExperimentResult"])(this._getEvalContext(), experiment, -1, false, "");
        } else {
            ({ result, trackingCall } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["runExperiment"])(experiment, null, this._getEvalContext()));
            this._fireSubscriptions(experiment, result);
        }
        // A hash to quickly tell if the assigned value changed
        const valueHash = JSON.stringify(result.value);
        // If the changes are already active, no need to re-apply them
        if (!forceRerun && result.inExperiment && existing && existing.valueHash === valueHash) {
            return result;
        }
        // Undo any existing changes
        if (existing) this._undoActiveAutoExperiment(experiment);
        // Apply new changes
        if (result.inExperiment) {
            const changeType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAutoExperimentChangeType"])(experiment);
            if (changeType === "redirect" && result.value.urlRedirect && experiment.urlPatterns) {
                const url = experiment.persistQueryString ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeQueryStrings"])(this._getContextUrl(), result.value.urlRedirect) : result.value.urlRedirect;
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isURLTargeted"])(url, experiment.urlPatterns)) {
                    this.log("Skipping redirect because original URL matches redirect URL", {
                        id: experiment.key
                    });
                    return result;
                }
                this._redirectedUrl = url;
                const { navigate, delay } = this._getNavigateFunction();
                if (navigate) {
                    if (isBrowser) {
                        var _this__options_maxNavigateDelay;
                        // Wait for the possibly-async tracking callback, bound by min and max delays
                        Promise.all([
                            ...trackingCall ? [
                                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["promiseTimeout"])(trackingCall, (_this__options_maxNavigateDelay = this._options.maxNavigateDelay) !== null && _this__options_maxNavigateDelay !== void 0 ? _this__options_maxNavigateDelay : 1000)
                            ] : [],
                            new Promise((resolve)=>{
                                var _this__options_navigateDelay;
                                return window.setTimeout(resolve, (_this__options_navigateDelay = this._options.navigateDelay) !== null && _this__options_navigateDelay !== void 0 ? _this__options_navigateDelay : delay);
                            })
                        ]).then(()=>{
                            try {
                                navigate(url);
                            } catch (e) {
                                console.error(e);
                            }
                        });
                    } else {
                        try {
                            navigate(url);
                        } catch (e) {
                            console.error(e);
                        }
                    }
                }
            } else if (changeType === "visual") {
                const undo = this._options.applyDomChangesCallback ? this._options.applyDomChangesCallback(result.value) : this._applyDOMChanges(result.value);
                if (undo) {
                    this._activeAutoExperiments.set(experiment, {
                        undo,
                        valueHash
                    });
                }
            }
        }
        return result;
    }
    _undoActiveAutoExperiment(exp) {
        const data = this._activeAutoExperiments.get(exp);
        if (data) {
            data.undo();
            this._activeAutoExperiments.delete(exp);
        }
    }
    _updateAllAutoExperiments(forceRerun) {
        if (!this._autoExperimentsAllowed) return;
        const experiments = this._options.experiments || [];
        // Stop any experiments that are no longer defined
        const keys = new Set(experiments);
        this._activeAutoExperiments.forEach((v, k)=>{
            if (!keys.has(k)) {
                v.undo();
                this._activeAutoExperiments.delete(k);
            }
        });
        // Re-run all new/updated experiments
        for (const exp of experiments){
            const result = this._runAutoExperiment(exp, forceRerun);
            // Once you're in a redirect experiment, break out of the loop and don't run any further experiments
            if (result !== null && result !== void 0 && result.inExperiment && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAutoExperimentChangeType"])(exp) === "redirect") {
                break;
            }
        }
    }
    _fireSubscriptions(experiment, result) {
        const key = experiment.key;
        // If assigned variation has changed, fire subscriptions
        const prev = this._assigned.get(key);
        // TODO: what if the experiment definition has changed?
        if (!prev || prev.result.inExperiment !== result.inExperiment || prev.result.variationId !== result.variationId) {
            this._assigned.set(key, {
                experiment,
                result
            });
            this._subscriptions.forEach((cb)=>{
                try {
                    cb(experiment, result);
                } catch (e) {
                    console.error(e);
                }
            });
        }
    }
    _recordChangedId(id) {
        this._completedChangeIds.add(id);
    }
    isOn(key) {
        return this.evalFeature(key).on;
    }
    isOff(key) {
        return this.evalFeature(key).off;
    }
    getFeatureValue(key, defaultValue) {
        const value = this.evalFeature(key).value;
        return value === null ? defaultValue : value;
    }
    /**
   * @deprecated Use {@link evalFeature}
   * @param id
   */ // eslint-disable-next-line
    feature(id) {
        return this.evalFeature(id);
    }
    evalFeature(id) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["evalFeature"])(id, this._getEvalContext());
    }
    log(msg, ctx) {
        if (!this.debug) return;
        if (this._options.log) this._options.log(msg, ctx);
        else console.log(msg, ctx);
    }
    getDeferredTrackingCalls() {
        return Array.from(this._deferredTrackingCalls.values());
    }
    setDeferredTrackingCalls(calls) {
        this._deferredTrackingCalls = new Map(calls.filter((c)=>c && c.experiment && c.result).map((c)=>{
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getExperimentDedupeKey"])(c.experiment, c.result),
                c
            ];
        }));
    }
    async fireDeferredTrackingCalls() {
        if (!this._options.trackingCallback) return;
        const promises = [];
        this._deferredTrackingCalls.forEach((call)=>{
            if (!call || !call.experiment || !call.result) {
                console.error("Invalid deferred tracking call", {
                    call: call
                });
            } else {
                promises.push(this._options.trackingCallback(call.experiment, call.result));
            }
        });
        this._deferredTrackingCalls.clear();
        await Promise.all(promises);
    }
    setTrackingCallback(callback) {
        this._options.trackingCallback = callback;
        this.fireDeferredTrackingCalls();
    }
    setEventLogger(logger) {
        this._options.eventLogger = logger;
    }
    async logEvent(eventName, properties) {
        if (this._destroyed) {
            console.error("Cannot log event to destroyed GrowthBook instance");
            return;
        }
        if (this._options.enableDevMode) {
            this.logs.push({
                eventName,
                properties,
                timestamp: Date.now().toString(),
                logType: "event"
            });
        }
        if (this._options.eventLogger) {
            try {
                await this._options.eventLogger(eventName, properties || {}, this._getUserContext());
            } catch (e) {
                console.error(e);
            }
        } else {
            console.error("No event logger configured");
        }
    }
    _saveDeferredTrack(data) {
        this._deferredTrackingCalls.set((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getExperimentDedupeKey"])(data.experiment, data.result), data);
    }
    _getContextUrl() {
        return this._options.url || (isBrowser ? window.location.href : "");
    }
    _isAutoExperimentBlockedByContext(experiment) {
        const changeType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$util$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAutoExperimentChangeType"])(experiment);
        if (changeType === "visual") {
            if (this._options.disableVisualExperiments) return true;
            if (this._options.disableJsInjection) {
                if (experiment.variations.some((v)=>v.js)) {
                    return true;
                }
            }
        } else if (changeType === "redirect") {
            if (this._options.disableUrlRedirectExperiments) return true;
            // Validate URLs
            try {
                const current = new URL(this._getContextUrl());
                for (const v of experiment.variations){
                    if (!v || !v.urlRedirect) continue;
                    const url = new URL(v.urlRedirect);
                    // If we're blocking cross origin redirects, block if the protocol or host is different
                    if (this._options.disableCrossOriginUrlRedirectExperiments) {
                        if (url.protocol !== current.protocol) return true;
                        if (url.host !== current.host) return true;
                    }
                }
            } catch (e) {
                // Problem parsing one of the URLs
                this.log("Error parsing current or redirect URL", {
                    id: experiment.key,
                    error: e
                });
                return true;
            }
        } else {
            // Block any unknown changeTypes
            return true;
        }
        if (experiment.changeId && (this._options.blockedChangeIds || []).includes(experiment.changeId)) {
            return true;
        }
        return false;
    }
    getRedirectUrl() {
        return this._redirectedUrl;
    }
    _getNavigateFunction() {
        if (this._options.navigate) {
            return {
                navigate: this._options.navigate,
                delay: 0
            };
        } else if (isBrowser) {
            return {
                navigate: (url)=>{
                    window.location.replace(url);
                },
                delay: 100
            };
        }
        return {
            navigate: null,
            delay: 0
        };
    }
    _applyDOMChanges(changes) {
        if (!isBrowser) return;
        const undo = [];
        if (changes.css) {
            const s = document.createElement("style");
            s.innerHTML = changes.css;
            document.head.appendChild(s);
            undo.push(()=>s.remove());
        }
        if (changes.js) {
            const script = document.createElement("script");
            script.innerHTML = changes.js;
            if (this._options.jsInjectionNonce) {
                script.nonce = this._options.jsInjectionNonce;
            }
            document.head.appendChild(script);
            undo.push(()=>script.remove());
        }
        if (changes.domMutations) {
            changes.domMutations.forEach((mutation)=>{
                undo.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dom$2d$mutator$2f$dist$2f$dom$2d$mutator$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].declarative(mutation).revert);
            });
        }
        return ()=>{
            undo.forEach((fn)=>fn());
        };
    }
    async refreshStickyBuckets(data) {
        if (this._options.stickyBucketService) {
            const ctx = this._getEvalContext();
            const docs = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAllStickyBucketAssignmentDocs"])(ctx, this._options.stickyBucketService, data);
            this._options.stickyBucketAssignmentDocs = docs;
        }
    }
    generateStickyBucketAssignmentDocsSync(stickyBucketService, payload) {
        if (!("getAllAssignmentsSync" in stickyBucketService)) {
            console.error("generating StickyBucketAssignmentDocs docs requires StickyBucketServiceSync");
            return;
        }
        const ctx = this._getEvalContext();
        const attributes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStickyBucketAttributes"])(ctx, payload);
        return stickyBucketService.getAllAssignmentsSync(attributes);
    }
    inDevMode() {
        return !!this._options.enableDevMode;
    }
    // context is technically private, but some tools depend on it so we can't mangle the name
    // Properties and methods that start with "_" are mangled by Terser (saves ~150 bytes)
    constructor(options){
        options = options || {};
        // These properties are all initialized in the constructor instead of above
        // This saves ~80 bytes in the final output
        this.version = SDK_VERSION;
        this._options = this.context = options;
        this._renderer = options.renderer || null;
        this._trackedExperiments = new Set();
        this._completedChangeIds = new Set();
        this._trackedFeatures = {};
        this.debug = !!options.debug;
        this._subscriptions = new Set();
        this.ready = false;
        this._assigned = new Map();
        this._activeAutoExperiments = new Map();
        this._triggeredExpKeys = new Set();
        this._initialized = false;
        this._redirectedUrl = "";
        this._deferredTrackingCalls = new Map();
        this._autoExperimentsAllowed = !options.disableExperimentsOnLoad;
        this._destroyCallbacks = [];
        this.logs = [];
        this.log = this.log.bind(this);
        this._saveDeferredTrack = this._saveDeferredTrack.bind(this);
        this._fireSubscriptions = this._fireSubscriptions.bind(this);
        this._recordChangedId = this._recordChangedId.bind(this);
        if (options.remoteEval) {
            if (options.decryptionKey) {
                throw new Error("Encryption is not available for remoteEval");
            }
            if (!options.clientKey) {
                throw new Error("Missing clientKey");
            }
            let isGbHost = false;
            try {
                isGbHost = !!new URL(options.apiHost || "").hostname.match(/growthbook\.io$/i);
            } catch (e) {
            // ignore invalid URLs
            }
            if (isGbHost) {
                throw new Error("Cannot use remoteEval on GrowthBook Cloud");
            }
        } else {
            if (options.cacheKeyAttributes) {
                throw new Error("cacheKeyAttributes are only used for remoteEval");
            }
        }
        if (options.stickyBucketService) {
            const s = options.stickyBucketService;
            this._saveStickyBucketAssignmentDoc = (doc)=>{
                return s.saveAssignments(doc);
            };
        }
        if (options.plugins) {
            for (const plugin of options.plugins){
                plugin(this);
            }
        }
        if (options.features) {
            this.ready = true;
        }
        if (isBrowser && options.enableDevMode) {
            window._growthbook = this;
            document.dispatchEvent(new Event("gbloaded"));
        }
        if (options.experiments) {
            this.ready = true;
            this._updateAllAutoExperiments();
        }
        // Hydrate sticky bucket service
        if (this._options.stickyBucketService && this._options.stickyBucketAssignmentDocs) {
            for(const key in this._options.stickyBucketAssignmentDocs){
                const doc = this._options.stickyBucketAssignmentDocs[key];
                if (doc) {
                    this._options.stickyBucketService.saveAssignments(doc).catch(()=>{
                    // Ignore hydration errors
                    });
                }
            }
        }
        // Legacy - passing in features/experiments into the constructor instead of using init
        if (this.ready) {
            this.refreshStickyBuckets(this.getPayload());
        }
    }
}
async function prefetchPayload(options) {
    // Create a temporary instance, just to fetch the payload
    const instance = new GrowthBook(options);
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$feature$2d$repository$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["refreshFeatures"])({
        instance,
        skipCache: options.skipCache,
        allowStale: false,
        backgroundSync: options.streaming
    });
    instance.destroy();
} //# sourceMappingURL=GrowthBook.mjs.map
}),
"[project]/node_modules/@growthbook/growthbook-react/dist/esm/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FeatureString",
    ()=>FeatureString,
    "FeaturesReady",
    ()=>FeaturesReady,
    "GrowthBookContext",
    ()=>GrowthBookContext,
    "GrowthBookProvider",
    ()=>GrowthBookProvider,
    "IfFeatureEnabled",
    ()=>IfFeatureEnabled,
    "getGrowthBookSSRData",
    ()=>getGrowthBookSSRData,
    "useExperiment",
    ()=>useExperiment,
    "useFeature",
    ()=>useFeature,
    "useFeatureIsOn",
    ()=>useFeatureIsOn,
    "useFeatureValue",
    ()=>useFeatureValue,
    "useGrowthBook",
    ()=>useGrowthBook,
    "useGrowthBookSSR",
    ()=>useGrowthBookSSR,
    "withRunExperiment",
    ()=>withRunExperiment
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$GrowthBook$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@growthbook/growthbook/dist/esm/GrowthBook.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
;
;
function _extends() {
    return _extends = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : "TURBOPACK unreachable", _extends.apply(null, arguments);
}
/** @deprecated */ const GrowthBookContext = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"]({});
/** @deprecated */ async function getGrowthBookSSRData(context) {
    // Server-side GrowthBook instance
    const gb = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$growthbook$2f$growthbook$2f$dist$2f$esm$2f$GrowthBook$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GrowthBook"]({
        ...context
    });
    // Load feature flags from network if needed
    if (context.clientKey) {
        await gb.init();
    }
    const data = {
        attributes: gb.getAttributes(),
        features: gb.getFeatures()
    };
    gb.destroy();
    return data;
}
/** @deprecated */ function useGrowthBookSSR(data) {
    const gb = useGrowthBook();
    // Only do this once to avoid infinite loops
    const isFirst = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](true);
    if (gb && isFirst.current) {
        gb.setFeatures(data.features);
        gb.setAttributes(data.attributes);
        isFirst.current = false;
    }
}
function useExperiment(exp) {
    const { growthbook } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](GrowthBookContext);
    return growthbook.run(exp);
}
function useFeature(id) {
    const growthbook = useGrowthBook();
    return growthbook.evalFeature(id);
}
function useFeatureIsOn(id) {
    const growthbook = useGrowthBook();
    return growthbook.isOn(id);
}
function useFeatureValue(id, fallback) {
    const growthbook = useGrowthBook();
    return growthbook.getFeatureValue(id, fallback);
}
function useGrowthBook() {
    const { growthbook } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](GrowthBookContext);
    if (!growthbook) {
        throw new Error("Missing or invalid GrowthBookProvider");
    }
    return growthbook;
}
function FeaturesReady(param) {
    let { children, timeout, fallback } = param;
    const gb = useGrowthBook();
    const [hitTimeout, setHitTimeout] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](false);
    const ready = gb ? gb.ready : false;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "FeaturesReady.useEffect": ()=>{
            if (timeout && !ready) {
                const timer = setTimeout({
                    "FeaturesReady.useEffect.timer": ()=>{
                        gb && gb.log("FeaturesReady timed out waiting for features to load", {
                            timeout
                        });
                        setHitTimeout(true);
                    }
                }["FeaturesReady.useEffect.timer"], timeout);
                return ({
                    "FeaturesReady.useEffect": ()=>clearTimeout(timer)
                })["FeaturesReady.useEffect"];
            }
        }
    }["FeaturesReady.useEffect"], [
        timeout,
        ready,
        gb
    ]);
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], null, ready || hitTimeout ? children : fallback || null);
}
function IfFeatureEnabled(param) {
    let { children, feature } = param;
    return useFeature(feature).on ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], null, children) : null;
}
function FeatureString(props) {
    const value = useFeature(props.feature).value;
    if (value !== null) {
        return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], null, value);
    }
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], null, props.default);
}
const withRunExperiment = (Component)=>{
    // eslint-disable-next-line
    const withRunExperimentWrapper = (props)=>/*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](GrowthBookContext.Consumer, null, (param)=>{
            let { growthbook } = param;
            return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](Component, _extends({}, props, {
                runExperiment: (exp)=>growthbook.run(exp)
            }));
        });
    return withRunExperimentWrapper;
};
withRunExperiment.displayName = "WithRunExperiment";
const GrowthBookProvider = (param)=>{
    let { children, growthbook } = param;
    // Tell growthbook how to re-render our app (for dev mode integration)
    // eslint-disable-next-line
    const [_, setRenderCount] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "GrowthBookProvider.useEffect": ()=>{
            if (!growthbook || !growthbook.setRenderer) return;
            growthbook.setRenderer({
                "GrowthBookProvider.useEffect": ()=>{
                    setRenderCount({
                        "GrowthBookProvider.useEffect": (v)=>v + 1
                    }["GrowthBookProvider.useEffect"]);
                }
            }["GrowthBookProvider.useEffect"]);
            return ({
                "GrowthBookProvider.useEffect": ()=>{
                    growthbook.setRenderer({
                        "GrowthBookProvider.useEffect": ()=>{
                        // do nothing
                        }
                    }["GrowthBookProvider.useEffect"]);
                }
            })["GrowthBookProvider.useEffect"];
        }
    }["GrowthBookProvider.useEffect"], [
        growthbook
    ]);
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](GrowthBookContext.Provider, {
        value: {
            growthbook
        }
    }, children);
};
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "disableSmoothScrollDuringRouteTransition", {
    enumerable: true,
    get: function() {
        return disableSmoothScrollDuringRouteTransition;
    }
});
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
function disableSmoothScrollDuringRouteTransition(fn, options) {
    if (options === void 0) options = {};
    // if only the hash is changed, we don't need to disable smooth scrolling
    // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX
    if (options.onlyHashChange) {
        fn();
        return;
    }
    const htmlElement = document.documentElement;
    const hasDataAttribute = htmlElement.dataset.scrollBehavior === 'smooth';
    // Since this is a breaking change, this is temporarily flagged
    // and will be false by default.
    // In the next major (v16), this will be automatically enabled
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        // Old behavior: always manipulate styles, but warn about upcoming change
        // Warn if smooth scrolling is detected but no data attribute is present
        if (("TURBOPACK compile-time value", "development") === 'development' && !hasDataAttribute && getComputedStyle(htmlElement).scrollBehavior === 'smooth') {
            (0, _warnonce.warnOnce)('Detected `scroll-behavior: smooth` on the `<html>` element. In a future version, ' + 'Next.js will no longer automatically disable smooth scrolling during route transitions. ' + 'To prepare for this change, add `data-scroll-behavior="smooth"` to your <html> element. ' + 'Learn more: https://nextjs.org/docs/messages/missing-data-scroll-behavior');
        }
    }
    // Proceed with temporarily disabling smooth scrolling
    const existing = htmlElement.style.scrollBehavior;
    htmlElement.style.scrollBehavior = 'auto';
    if (!options.dontForceLayout) {
        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.
        // Otherwise it will not pickup the change in scrollBehavior
        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042
        htmlElement.getClientRects();
    }
    fn();
    htmlElement.style.scrollBehavior = existing;
} //# sourceMappingURL=disable-smooth-scroll.js.map
}),
"[project]/node_modules/next/dist/client/components/bfcache.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useRouterBFCache", {
    enumerable: true,
    get: function() {
        return useRouterBFCache;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
// When the flag is disabled, only track the currently active tree
const MAX_BF_CACHE_ENTRIES = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 1;
function useRouterBFCache(activeTree, activeStateKey) {
    // The currently active entry. The entries form a linked list, sorted in
    // order of most recently active. This allows us to reuse parts of the list
    // without cloning, unless there's a reordering or removal.
    // TODO: Once we start tracking back/forward history at each route level,
    // we should use the history order instead. In other words, when traversing
    // to an existing entry as a result of a popstate event, we should maintain
    // the existing order instead of moving it to the front of the list. I think
    // an initial implementation of this could be to pass an incrementing id
    // to history.pushState/replaceState, then use that here for ordering.
    const [prevActiveEntry, setPrevActiveEntry] = (0, _react.useState)(()=>{
        const initialEntry = {
            tree: activeTree,
            stateKey: activeStateKey,
            next: null
        };
        return initialEntry;
    });
    if (prevActiveEntry.tree === activeTree) {
        // Fast path. The active tree hasn't changed, so we can reuse the
        // existing state.
        return prevActiveEntry;
    }
    // The route tree changed. Note that this doesn't mean that the tree changed
    // *at this level*  the change may be due to a child route. Either way, we
    // need to either add or update the router tree in the bfcache.
    //
    // The rest of the code looks more complicated than it actually is because we
    // can't mutate the state in place; we have to copy-on-write.
    // Create a new entry for the active cache key. This is the head of the new
    // linked list.
    const newActiveEntry = {
        tree: activeTree,
        stateKey: activeStateKey,
        next: null
    };
    // We need to append the old list onto the new list. If the head of the new
    // list was already present in the cache, then we'll need to clone everything
    // that came before it. Then we can reuse the rest.
    let n = 1;
    let oldEntry = prevActiveEntry;
    let clonedEntry = newActiveEntry;
    while(oldEntry !== null && n < MAX_BF_CACHE_ENTRIES){
        if (oldEntry.stateKey === activeStateKey) {
            // Fast path. This entry in the old list that corresponds to the key that
            // is now active. We've already placed a clone of this entry at the front
            // of the new list. We can reuse the rest of the old list without cloning.
            // NOTE: We don't need to worry about eviction in this case because we
            // haven't increased the size of the cache, and we assume the max size
            // is constant across renders. If we were to change it to a dynamic limit,
            // then the implementation would need to account for that.
            clonedEntry.next = oldEntry.next;
            break;
        } else {
            // Clone the entry and append it to the list.
            n++;
            const entry = {
                tree: oldEntry.tree,
                stateKey: oldEntry.stateKey,
                next: null
            };
            clonedEntry.next = entry;
            clonedEntry = entry;
        }
        oldEntry = oldEntry.next;
    }
    setPrevActiveEntry(newActiveEntry);
    return newActiveEntry;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=bfcache.js.map
}),
"[project]/node_modules/next/dist/client/components/layout-router.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, /**
 * OuterLayoutRouter handles the current segment as well as <Offscreen> rendering of other segments.
 * It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.
 */ "default", {
    enumerable: true,
    get: function() {
        return OuterLayoutRouter;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _reactdom = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)"));
const _approutercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)");
const _fetchserverresponse = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-client] (ecmascript)");
const _unresolvedthenable = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/unresolved-thenable.js [app-client] (ecmascript)");
const _errorboundary = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/error-boundary.js [app-client] (ecmascript)");
const _matchsegments = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/match-segments.js [app-client] (ecmascript)");
const _disablesmoothscroll = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js [app-client] (ecmascript)");
const _redirectboundary = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-boundary.js [app-client] (ecmascript)");
const _errorboundary1 = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/error-boundary.js [app-client] (ecmascript)");
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-client] (ecmascript)");
const _hasinterceptionrouteincurrenttree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-client] (ecmascript)");
const _useactionqueue = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/use-action-queue.js [app-client] (ecmascript)");
const _bfcache = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/bfcache.js [app-client] (ecmascript)");
const _apppaths = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/app-paths.js [app-client] (ecmascript)");
const Activity = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : null;
/**
 * Add refetch marker to router state at the point of the current layout segment.
 * This ensures the response returned is not further down than the current layout segment.
 */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {
    if (segmentPathToWalk) {
        const [segment, parallelRouteKey] = segmentPathToWalk;
        const isLast = segmentPathToWalk.length === 2;
        if ((0, _matchsegments.matchSegment)(treeToRecreate[0], segment)) {
            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {
                if (isLast) {
                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);
                    return [
                        treeToRecreate[0],
                        {
                            ...treeToRecreate[1],
                            [parallelRouteKey]: [
                                subTree[0],
                                subTree[1],
                                subTree[2],
                                'refetch'
                            ]
                        }
                    ];
                }
                return [
                    treeToRecreate[0],
                    {
                        ...treeToRecreate[1],
                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])
                    }
                ];
            }
        }
    }
    return treeToRecreate;
}
const __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = _reactdom.default.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available
/**
 * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning
 */ function findDOMNode(instance) {
    // Tree-shake for server bundle
    if (typeof window === 'undefined') return null;
    // __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.
    // We need to lazily reference it.
    const internal_reactDOMfindDOMNode = __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode;
    return internal_reactDOMfindDOMNode(instance);
}
const rectProperties = [
    'bottom',
    'height',
    'left',
    'right',
    'top',
    'width',
    'x',
    'y'
];
/**
 * Check if a HTMLElement is hidden or fixed/sticky position
 */ function shouldSkipElement(element) {
    // we ignore fixed or sticky positioned elements since they'll likely pass the "in-viewport" check
    // and will result in a situation we bail on scroll because of something like a fixed nav,
    // even though the actual page content is offscreen
    if ([
        'sticky',
        'fixed'
    ].includes(getComputedStyle(element).position)) {
        if ("TURBOPACK compile-time truthy", 1) {
            console.warn('Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:', element);
        }
        return true;
    }
    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`
    // because `offsetParent` doesn't consider document/body
    const rect = element.getBoundingClientRect();
    return rectProperties.every((item)=>rect[item] === 0);
}
/**
 * Check if the top corner of the HTMLElement is in the viewport.
 */ function topOfElementInViewport(element, viewportHeight) {
    const rect = element.getBoundingClientRect();
    return rect.top >= 0 && rect.top <= viewportHeight;
}
/**
 * Find the DOM node for a hash fragment.
 * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.
 * If the hash fragment is an id, the page has to scroll to the element with that id.
 * If the hash fragment is a name, the page has to scroll to the first element with that name.
 */ function getHashFragmentDomNode(hashFragment) {
    // If the hash fragment is `top` the page has to scroll to the top of the page.
    if (hashFragment === 'top') {
        return document.body;
    }
    var _document_getElementById;
    // If the hash fragment is an id, the page has to scroll to the element with that id.
    return (_document_getElementById = document.getElementById(hashFragment)) != null ? _document_getElementById : document.getElementsByName(hashFragment)[0];
}
class InnerScrollAndFocusHandler extends _react.default.Component {
    componentDidMount() {
        this.handlePotentialScroll();
    }
    componentDidUpdate() {
        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.
        if (this.props.focusAndScrollRef.apply) {
            this.handlePotentialScroll();
        }
    }
    render() {
        return this.props.children;
    }
    constructor(...args){
        super(...args), this.handlePotentialScroll = ()=>{
            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.
            const { focusAndScrollRef, segmentPath } = this.props;
            if (focusAndScrollRef.apply) {
                // segmentPaths is an array of segment paths that should be scrolled to
                // if the current segment path is not in the array, the scroll is not applied
                // unless the array is empty, in which case the scroll is always applied
                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=>segmentPath.every((segment, index)=>(0, _matchsegments.matchSegment)(segment, scrollRefSegmentPath[index])))) {
                    return;
                }
                let domNode = null;
                const hashFragment = focusAndScrollRef.hashFragment;
                if (hashFragment) {
                    domNode = getHashFragmentDomNode(hashFragment);
                }
                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.
                // This already caused a bug where the first child was a <link/> in head.
                if (!domNode) {
                    domNode = findDOMNode(this);
                }
                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.
                if (!(domNode instanceof Element)) {
                    return;
                }
                // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.
                // If the element is skipped, try to select the next sibling and try again.
                while(!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)){
                    if ("TURBOPACK compile-time truthy", 1) {
                        var _domNode_parentElement;
                        if (((_domNode_parentElement = domNode.parentElement) == null ? void 0 : _domNode_parentElement.localName) === 'head') {
                        // TODO: We enter this state when metadata was rendered as part of the page or via Next.js.
                        // This is always a bug in Next.js and caused by React hoisting metadata.
                        // We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.
                        }
                    }
                    // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.
                    if (domNode.nextElementSibling === null) {
                        return;
                    }
                    domNode = domNode.nextElementSibling;
                }
                // State is mutated to ensure that the focus and scroll is applied only once.
                focusAndScrollRef.apply = false;
                focusAndScrollRef.hashFragment = null;
                focusAndScrollRef.segmentPaths = [];
                (0, _disablesmoothscroll.disableSmoothScrollDuringRouteTransition)(()=>{
                    // In case of hash scroll, we only need to scroll the element into view
                    if (hashFragment) {
                        ;
                        domNode.scrollIntoView();
                        return;
                    }
                    // Store the current viewport height because reading `clientHeight` causes a reflow,
                    // and it won't change during this function.
                    const htmlElement = document.documentElement;
                    const viewportHeight = htmlElement.clientHeight;
                    // If the element's top edge is already in the viewport, exit early.
                    if (topOfElementInViewport(domNode, viewportHeight)) {
                        return;
                    }
                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages
                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)
                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left
                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically
                    htmlElement.scrollTop = 0;
                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document
                    if (!topOfElementInViewport(domNode, viewportHeight)) {
                        // Scroll into view doesn't scroll horizontally by default when not needed
                        ;
                        domNode.scrollIntoView();
                    }
                }, {
                    // We will force layout by querying domNode position
                    dontForceLayout: true,
                    onlyHashChange: focusAndScrollRef.onlyHashChange
                });
                // Mutate after scrolling so that it can be read by `disableSmoothScrollDuringRouteTransition`
                focusAndScrollRef.onlyHashChange = false;
                // Set focus on the element
                domNode.focus();
            }
        };
    }
}
function ScrollAndFocusHandler(param) {
    let { segmentPath, children } = param;
    const context = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);
    if (!context) {
        throw Object.defineProperty(new Error('invariant global layout router not mounted'), "__NEXT_ERROR_CODE", {
            value: "E473",
            enumerable: false,
            configurable: true
        });
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerScrollAndFocusHandler, {
        segmentPath: segmentPath,
        focusAndScrollRef: context.focusAndScrollRef,
        children: children
    });
}
/**
 * InnerLayoutRouter handles rendering the provided segment based on the cache.
 */ function InnerLayoutRouter(param) {
    let { tree, segmentPath, cacheNode, url } = param;
    const context = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);
    if (!context) {
        throw Object.defineProperty(new Error('invariant global layout router not mounted'), "__NEXT_ERROR_CODE", {
            value: "E473",
            enumerable: false,
            configurable: true
        });
    }
    const { tree: fullTree } = context;
    // `rsc` represents the renderable node for this segment.
    // If this segment has a `prefetchRsc`, it's the statically prefetched data.
    // We should use that on initial render instead of `rsc`. Then we'll switch
    // to `rsc` when the dynamic response streams in.
    //
    // If no prefetch data is available, then we go straight to rendering `rsc`.
    const resolvedPrefetchRsc = cacheNode.prefetchRsc !== null ? cacheNode.prefetchRsc : cacheNode.rsc;
    // We use `useDeferredValue` to handle switching between the prefetched and
    // final values. The second argument is returned on initial render, then it
    // re-renders with the first argument.
    const rsc = (0, _react.useDeferredValue)(cacheNode.rsc, resolvedPrefetchRsc);
    // `rsc` is either a React node or a promise for a React node, except we
    // special case `null` to represent that this segment's data is missing. If
    // it's a promise, we need to unwrap it so we can determine whether or not the
    // data is missing.
    const resolvedRsc = typeof rsc === 'object' && rsc !== null && typeof rsc.then === 'function' ? (0, _react.use)(rsc) : rsc;
    if (!resolvedRsc) {
        // The data for this segment is not available, and there's no pending
        // navigation that will be able to fulfill it. We need to fetch more from
        // the server and patch the cache.
        // Check if there's already a pending request.
        let lazyData = cacheNode.lazyData;
        if (lazyData === null) {
            /**
       * Router state with refetch marker added
       */ // TODO-APP: remove ''
            const refetchTree = walkAddRefetch([
                '',
                ...segmentPath
            ], fullTree);
            const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(fullTree);
            const navigatedAt = Date.now();
            cacheNode.lazyData = lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(url, location.origin), {
                flightRouterState: refetchTree,
                nextUrl: includeNextUrl ? context.nextUrl : null
            }).then((serverResponse)=>{
                (0, _react.startTransition)(()=>{
                    (0, _useactionqueue.dispatchAppRouterAction)({
                        type: _routerreducertypes.ACTION_SERVER_PATCH,
                        previousTree: fullTree,
                        serverResponse,
                        navigatedAt
                    });
                });
                return serverResponse;
            });
            // Suspend while waiting for lazyData to resolve
            (0, _react.use)(lazyData);
        }
        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.
        // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.
        (0, _react.use)(_unresolvedthenable.unresolvedThenable);
    }
    // If we get to this point, then we know we have something we can render.
    const subtree = /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {
        value: {
            parentTree: tree,
            parentCacheNode: cacheNode,
            parentSegmentPath: segmentPath,
            // TODO-APP: overriding of url for parallel routes
            url: url
        },
        children: resolvedRsc
    });
    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`
    return subtree;
}
/**
 * Renders suspense boundary with the provided "loading" property as the fallback.
 * If no loading property is provided it renders the children without a suspense boundary.
 */ function LoadingBoundary(param) {
    let { loading, children } = param;
    // If loading is a promise, unwrap it. This happens in cases where we haven't
    // yet received the loading data from the server  which includes whether or
    // not this layout has a loading component at all.
    //
    // It's OK to suspend here instead of inside the fallback because this
    // promise will resolve simultaneously with the data for the segment itself.
    // So it will never suspend for longer than it would have if we didn't use
    // a Suspense fallback at all.
    let loadingModuleData;
    if (typeof loading === 'object' && loading !== null && typeof loading.then === 'function') {
        const promiseForLoading = loading;
        loadingModuleData = (0, _react.use)(promiseForLoading);
    } else {
        loadingModuleData = loading;
    }
    if (loadingModuleData) {
        const loadingRsc = loadingModuleData[0];
        const loadingStyles = loadingModuleData[1];
        const loadingScripts = loadingModuleData[2];
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {
            fallback: /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                children: [
                    loadingStyles,
                    loadingScripts,
                    loadingRsc
                ]
            }),
            children: children
        });
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
        children: children
    });
}
function OuterLayoutRouter(param) {
    let { parallelRouterKey, error, errorStyles, errorScripts, templateStyles, templateScripts, template, notFound, forbidden, unauthorized, segmentViewBoundaries } = param;
    const context = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);
    if (!context) {
        throw Object.defineProperty(new Error('invariant expected layout router to be mounted'), "__NEXT_ERROR_CODE", {
            value: "E56",
            enumerable: false,
            configurable: true
        });
    }
    const { parentTree, parentCacheNode, parentSegmentPath, url } = context;
    // Get the CacheNode for this segment by reading it from the parent segment's
    // child map.
    const parentParallelRoutes = parentCacheNode.parallelRoutes;
    let segmentMap = parentParallelRoutes.get(parallelRouterKey);
    // If the parallel router cache node does not exist yet, create it.
    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.
    if (!segmentMap) {
        segmentMap = new Map();
        parentParallelRoutes.set(parallelRouterKey, segmentMap);
    }
    const parentTreeSegment = parentTree[0];
    const segmentPath = parentSegmentPath === null ? // the code. We should clean this up.
    [
        parallelRouterKey
    ] : parentSegmentPath.concat([
        parentTreeSegment,
        parallelRouterKey
    ]);
    // The "state" key of a segment is the one passed to React  it represents the
    // identity of the UI tree. Whenever the state key changes, the tree is
    // recreated and the state is reset. In the App Router model, search params do
    // not cause state to be lost, so two segments with the same segment path but
    // different search params should have the same state key.
    //
    // The "cache" key of a segment, however, *does* include the search params, if
    // it's possible that the segment accessed the search params on the server.
    // (This only applies to page segments; layout segments cannot access search
    // params on the server.)
    const activeTree = parentTree[1][parallelRouterKey];
    const activeSegment = activeTree[0];
    const activeStateKey = (0, _createroutercachekey.createRouterCacheKey)(activeSegment, true) // no search params
    ;
    // At each level of the route tree, not only do we render the currently
    // active segment  we also render the last N segments that were active at
    // this level inside a hidden <Activity> boundary, to preserve their state
    // if or when the user navigates to them again.
    //
    // bfcacheEntry is a linked list of FlightRouterStates.
    let bfcacheEntry = (0, _bfcache.useRouterBFCache)(activeTree, activeStateKey);
    let children = [];
    do {
        const tree = bfcacheEntry.tree;
        const stateKey = bfcacheEntry.stateKey;
        const segment = tree[0];
        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);
        // Read segment path from the parallel router cache node.
        let cacheNode = segmentMap.get(cacheKey);
        if (cacheNode === undefined) {
            // When data is not available during rendering client-side we need to fetch
            // it from the server.
            const newLazyCacheNode = {
                lazyData: null,
                rsc: null,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                loading: null,
                navigatedAt: -1
            };
            // Flight data fetch kicked off during render and put into the cache.
            cacheNode = newLazyCacheNode;
            segmentMap.set(cacheKey, newLazyCacheNode);
        }
        /*
    - Error boundary
      - Only renders error boundary if error component is provided.
      - Rendered for each segment to ensure they have their own error state.
      - When gracefully degrade for bots, skip rendering error boundary.
    - Loading boundary
      - Only renders suspense boundary if loading components is provided.
      - Rendered for each segment to ensure they have their own loading state.
      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.
  */ let segmentBoundaryTriggerNode = null;
        let segmentViewStateNode = null;
        if ("TURBOPACK compile-time truthy", 1) {
            const { SegmentBoundaryTriggerNode, SegmentViewStateNode } = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js [app-client] (ecmascript)");
            const pagePrefix = (0, _apppaths.normalizeAppPath)(url);
            segmentViewStateNode = /*#__PURE__*/ (0, _jsxruntime.jsx)(SegmentViewStateNode, {
                page: pagePrefix
            }, pagePrefix);
            segmentBoundaryTriggerNode = /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(SegmentBoundaryTriggerNode, {})
            });
        }
        // TODO: The loading module data for a segment is stored on the parent, then
        // applied to each of that parent segment's parallel route slots. In the
        // simple case where there's only one parallel route (the `children` slot),
        // this is no different from if the loading module data where stored on the
        // child directly. But I'm not sure this actually makes sense when there are
        // multiple parallel routes. It's not a huge issue because you always have
        // the option to define a narrower loading boundary for a particular slot. But
        // this sort of smells like an implementation accident to me.
        const loadingModuleData = parentCacheNode.loading;
        let child = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_approutercontextsharedruntime.TemplateContext.Provider, {
            value: /*#__PURE__*/ (0, _jsxruntime.jsxs)(ScrollAndFocusHandler, {
                segmentPath: segmentPath,
                children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {
                        errorComponent: error,
                        errorStyles: errorStyles,
                        errorScripts: errorScripts,
                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(LoadingBoundary, {
                            loading: loadingModuleData,
                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary1.HTTPAccessFallbackBoundary, {
                                notFound: notFound,
                                forbidden: forbidden,
                                unauthorized: unauthorized,
                                children: /*#__PURE__*/ (0, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {
                                    children: [
                                        /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerLayoutRouter, {
                                            url: url,
                                            tree: tree,
                                            cacheNode: cacheNode,
                                            segmentPath: segmentPath
                                        }),
                                        segmentBoundaryTriggerNode
                                    ]
                                })
                            })
                        })
                    }),
                    segmentViewStateNode
                ]
            }),
            children: [
                templateStyles,
                templateScripts,
                template
            ]
        }, stateKey);
        if ("TURBOPACK compile-time truthy", 1) {
            const { SegmentStateProvider } = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js [app-client] (ecmascript)");
            child = /*#__PURE__*/ (0, _jsxruntime.jsxs)(SegmentStateProvider, {
                children: [
                    child,
                    segmentViewBoundaries
                ]
            }, stateKey);
        }
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        children.push(child);
        bfcacheEntry = bfcacheEntry.next;
    }while (bfcacheEntry !== null)
    return children;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=layout-router.js.map
}),
"[project]/node_modules/next/dist/client/components/render-from-template-context.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return RenderFromTemplateContext;
    }
});
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _approutercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)");
function RenderFromTemplateContext() {
    const children = (0, _react.useContext)(_approutercontextsharedruntime.TemplateContext);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
        children: children
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=render-from-template-context.js.map
}),
"[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ReflectAdapter", {
    enumerable: true,
    get: function() {
        return ReflectAdapter;
    }
});
class ReflectAdapter {
    static get(target, prop, receiver) {
        const value = Reflect.get(target, prop, receiver);
        if (typeof value === 'function') {
            return value.bind(target);
        }
        return value;
    }
    static set(target, prop, value, receiver) {
        return Reflect.set(target, prop, value, receiver);
    }
    static has(target, prop) {
        return Reflect.has(target, prop);
    }
    static deleteProperty(target, prop) {
        return Reflect.deleteProperty(target, prop);
    }
} //# sourceMappingURL=reflect.js.map
}),
"[project]/node_modules/next/dist/shared/lib/utils/reflect-utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// This regex will have fast negatives meaning valid identifiers may not pass
// this test. However this is only used during static generation to provide hints
// about why a page bailed out of some or all prerendering and we can use bracket notation
// for example while `_` is a valid identifier it's ok to print `searchParams['_']`
// even if this would have been fine too `searchParams._`
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    describeHasCheckingStringProperty: null,
    describeStringPropertyAccess: null,
    wellKnownProperties: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    describeHasCheckingStringProperty: function() {
        return describeHasCheckingStringProperty;
    },
    describeStringPropertyAccess: function() {
        return describeStringPropertyAccess;
    },
    wellKnownProperties: function() {
        return wellKnownProperties;
    }
});
const isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/;
function describeStringPropertyAccess(target, prop) {
    if (isDefinitelyAValidIdentifier.test(prop)) {
        return "`" + target + "." + prop + "`";
    }
    return "`" + target + "[" + JSON.stringify(prop) + "]`";
}
function describeHasCheckingStringProperty(target, prop) {
    const stringifiedProp = JSON.stringify(prop);
    return "`Reflect.has(" + target + ", " + stringifiedProp + ")`, `" + stringifiedProp + " in " + target + "`, or similar";
}
const wellKnownProperties = new Set([
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toString',
    'valueOf',
    'toLocaleString',
    // Promise prototype
    // fallthrough
    'then',
    'catch',
    'finally',
    // React Promise extension
    // fallthrough
    'status',
    // React introspection
    'displayName',
    '_debugInfo',
    // Common tested properties
    // fallthrough
    'toJSON',
    '$$typeof',
    '__esModule'
]); //# sourceMappingURL=reflect-utils.js.map
}),
"[project]/node_modules/next/dist/client/request/search-params.browser.dev.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createRenderSearchParamsFromClient", {
    enumerable: true,
    get: function() {
        return createRenderSearchParamsFromClient;
    }
});
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)");
const _reflectutils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/reflect-utils.js [app-client] (ecmascript)");
const CachedSearchParams = new WeakMap();
function makeUntrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams) {
    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    const promise = Promise.resolve(underlyingSearchParams);
    Object.keys(underlyingSearchParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
            // These properties cannot be shadowed because they need to be the
            // true underlying value for Promises to work correctly at runtime
            unproxiedProperties.push(prop);
        } else {
            proxiedProperties.add(prop);
            promise[prop] = underlyingSearchParams[prop];
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (typeof prop === 'string') {
                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('searchParams', prop);
                    warnForSyncAccess(expression);
                }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return Reflect.set(target, prop, value, receiver);
        },
        has (target, prop) {
            if (typeof prop === 'string') {
                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, _reflectutils.describeHasCheckingStringProperty)('searchParams', prop);
                    warnForSyncAccess(expression);
                }
            }
            return Reflect.has(target, prop);
        },
        ownKeys (target) {
            warnForSyncSpread();
            return Reflect.ownKeys(target);
        }
    });
    CachedSearchParams.set(underlyingSearchParams, proxiedPromise);
    return proxiedPromise;
}
// Similar to `makeUntrackedExoticSearchParamsWithDevWarnings`, but just logging
// the sync access without actually defining the search params on the promise.
function makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams) {
    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    const promise = Promise.resolve(underlyingSearchParams);
    Object.keys(underlyingSearchParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
            // These properties cannot be shadowed because they need to be the
            // true underlying value for Promises to work correctly at runtime
            unproxiedProperties.push(prop);
        } else {
            proxiedProperties.add(prop);
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (typeof prop === 'string') {
                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('searchParams', prop);
                    warnForSyncAccess(expression);
                }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return Reflect.set(target, prop, value, receiver);
        },
        has (target, prop) {
            if (typeof prop === 'string') {
                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, _reflectutils.describeHasCheckingStringProperty)('searchParams', prop);
                    warnForSyncAccess(expression);
                }
            }
            return Reflect.has(target, prop);
        },
        ownKeys (target) {
            warnForSyncSpread();
            return Reflect.ownKeys(target);
        }
    });
    CachedSearchParams.set(underlyingSearchParams, proxiedPromise);
    return proxiedPromise;
}
function warnForSyncAccess(expression) {
    console.error("A searchParam property was accessed directly with " + expression + ". " + "`searchParams` should be unwrapped with `React.use()` before accessing its properties. " + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis");
}
function warnForSyncSpread() {
    console.error("The keys of `searchParams` were accessed directly. " + "`searchParams` should be unwrapped with `React.use()` before accessing its properties. " + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis");
}
function createRenderSearchParamsFromClient(underlyingSearchParams) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return makeUntrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=search-params.browser.dev.js.map
}),
"[project]/node_modules/next/dist/client/request/search-params.browser.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createRenderSearchParamsFromClient", {
    enumerable: true,
    get: function() {
        return createRenderSearchParamsFromClient;
    }
});
const createRenderSearchParamsFromClient = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[project]/node_modules/next/dist/client/request/search-params.browser.dev.js [app-client] (ecmascript)").createRenderSearchParamsFromClient : "TURBOPACK unreachable";
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=search-params.browser.js.map
}),
"[project]/node_modules/next/dist/client/request/params.browser.dev.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createRenderParamsFromClient", {
    enumerable: true,
    get: function() {
        return createRenderParamsFromClient;
    }
});
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)");
const _reflectutils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/reflect-utils.js [app-client] (ecmascript)");
const CachedParams = new WeakMap();
function makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    // We don't use makeResolvedReactPromise here because params
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = Promise.resolve(underlyingParams);
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    Object.keys(underlyingParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
        // These properties cannot be shadowed because they need to be the
        // true underlying value for Promises to work correctly at runtime
        } else {
            proxiedProperties.add(prop);
            promise[prop] = underlyingParams[prop];
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (typeof prop === 'string') {
                if (proxiedProperties.has(prop)) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('params', prop);
                    warnForSyncAccess(expression);
                }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return _reflect.ReflectAdapter.set(target, prop, value, receiver);
        },
        ownKeys (target) {
            warnForEnumeration(unproxiedProperties);
            return Reflect.ownKeys(target);
        }
    });
    CachedParams.set(underlyingParams, proxiedPromise);
    return proxiedPromise;
}
// Similar to `makeDynamicallyTrackedExoticParamsWithDevWarnings`, but just
// logging the sync access without actually defining the params on the promise.
function makeDynamicallyTrackedParamsWithDevWarnings(underlyingParams) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    // We don't use makeResolvedReactPromise here because params
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = Promise.resolve(underlyingParams);
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    Object.keys(underlyingParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
        // These properties cannot be shadowed because they need to be the
        // true underlying value for Promises to work correctly at runtime
        } else {
            proxiedProperties.add(prop);
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (typeof prop === 'string') {
                if (proxiedProperties.has(prop)) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('params', prop);
                    warnForSyncAccess(expression);
                }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return _reflect.ReflectAdapter.set(target, prop, value, receiver);
        },
        ownKeys (target) {
            warnForEnumeration(unproxiedProperties);
            return Reflect.ownKeys(target);
        }
    });
    CachedParams.set(underlyingParams, proxiedPromise);
    return proxiedPromise;
}
function warnForSyncAccess(expression) {
    console.error("A param property was accessed directly with " + expression + ". `params` is now a Promise and should be unwrapped with `React.use()` before accessing properties of the underlying params object. In this version of Next.js direct access to param properties is still supported to facilitate migration but in a future version you will be required to unwrap `params` with `React.use()`.");
}
function warnForEnumeration(missingProperties) {
    if (missingProperties.length) {
        const describedMissingProperties = describeListOfPropertyNames(missingProperties);
        console.error("params are being enumerated incompletely missing these properties: " + describedMissingProperties + ". " + "`params` should be unwrapped with `React.use()` before using its value. " + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis");
    } else {
        console.error("params are being enumerated. " + "`params` should be unwrapped with `React.use()` before using its value. " + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis");
    }
}
function describeListOfPropertyNames(properties) {
    switch(properties.length){
        case 0:
            throw Object.defineProperty(new _invarianterror.InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.'), "__NEXT_ERROR_CODE", {
                value: "E531",
                enumerable: false,
                configurable: true
            });
        case 1:
            return "`" + properties[0] + "`";
        case 2:
            return "`" + properties[0] + "` and `" + properties[1] + "`";
        default:
            {
                let description = '';
                for(let i = 0; i < properties.length - 1; i++){
                    description += "`" + properties[i] + "`, ";
                }
                description += ", and `" + properties[properties.length - 1] + "`";
                return description;
            }
    }
}
function createRenderParamsFromClient(clientParams) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return makeDynamicallyTrackedExoticParamsWithDevWarnings(clientParams);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=params.browser.dev.js.map
}),
"[project]/node_modules/next/dist/client/request/params.browser.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createRenderParamsFromClient", {
    enumerable: true,
    get: function() {
        return createRenderParamsFromClient;
    }
});
const createRenderParamsFromClient = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[project]/node_modules/next/dist/client/request/params.browser.dev.js [app-client] (ecmascript)").createRenderParamsFromClient : "TURBOPACK unreachable";
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=params.browser.js.map
}),
"[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createDedupedByCallsiteServerErrorLoggerDev", {
    enumerable: true,
    get: function() {
        return createDedupedByCallsiteServerErrorLoggerDev;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const errorRef = {
    current: null
};
// React.cache is currently only available in canary/experimental React channels.
const cache = typeof _react.cache === 'function' ? _react.cache : (fn)=>fn;
// When Cache Components is enabled, we record these as errors so that they
// are captured by the dev overlay as it's more critical to fix these
// when enabled.
const logErrorOrWarn = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : console.warn;
// We don't want to dedupe across requests.
// The developer might've just attempted to fix the warning so we should warn again if it still happens.
const flushCurrentErrorIfNew = cache((key)=>{
    try {
        logErrorOrWarn(errorRef.current);
    } finally{
        errorRef.current = null;
    }
});
function createDedupedByCallsiteServerErrorLoggerDev(getMessage) {
    return function logDedupedError() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        const message = getMessage(...args);
        if ("TURBOPACK compile-time truthy", 1) {
            var _stack;
            const callStackFrames = (_stack = new Error().stack) == null ? void 0 : _stack.split('\n');
            if (callStackFrames === undefined || callStackFrames.length < 4) {
                logErrorOrWarn(message);
            } else {
                // Error:
                //   logDedupedError
                //   asyncApiBeingAccessedSynchronously
                //   <userland callsite>
                // TODO: This breaks if sourcemaps with ignore lists are enabled.
                const key = callStackFrames[4];
                errorRef.current = message;
                flushCurrentErrorIfNew(key);
            }
        } else //TURBOPACK unreachable
        ;
    };
} //# sourceMappingURL=create-deduped-by-callsite-server-error-logger.js.map
}),
"[project]/node_modules/next/dist/server/app-render/after-task-async-storage-instance.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "afterTaskAsyncStorageInstance", {
    enumerable: true,
    get: function() {
        return afterTaskAsyncStorageInstance;
    }
});
const _asynclocalstorage = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/async-local-storage.js [app-client] (ecmascript)");
const afterTaskAsyncStorageInstance = (0, _asynclocalstorage.createAsyncLocalStorage)(); //# sourceMappingURL=after-task-async-storage-instance.js.map
}),
"[project]/node_modules/next/dist/server/app-render/after-task-async-storage.external.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "afterTaskAsyncStorage", {
    enumerable: true,
    get: function() {
        return _aftertaskasyncstorageinstance.afterTaskAsyncStorageInstance;
    }
});
const _aftertaskasyncstorageinstance = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/after-task-async-storage-instance.js [app-client] (ecmascript)"); //# sourceMappingURL=after-task-async-storage.external.js.map
}),
"[project]/node_modules/next/dist/server/request/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    isRequestAPICallableInsideAfter: null,
    throwForSearchParamsAccessInUseCache: null,
    throwWithStaticGenerationBailoutError: null,
    throwWithStaticGenerationBailoutErrorWithDynamicError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    isRequestAPICallableInsideAfter: function() {
        return isRequestAPICallableInsideAfter;
    },
    throwForSearchParamsAccessInUseCache: function() {
        return throwForSearchParamsAccessInUseCache;
    },
    throwWithStaticGenerationBailoutError: function() {
        return throwWithStaticGenerationBailoutError;
    },
    throwWithStaticGenerationBailoutErrorWithDynamicError: function() {
        return throwWithStaticGenerationBailoutErrorWithDynamicError;
    }
});
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-client] (ecmascript)");
const _aftertaskasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/after-task-async-storage.external.js [app-client] (ecmascript)");
function throwWithStaticGenerationBailoutError(route, expression) {
    throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError("Route ".concat(route, " couldn't be rendered statically because it used ").concat(expression, ". See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering")), "__NEXT_ERROR_CODE", {
        value: "E576",
        enumerable: false,
        configurable: true
    });
}
function throwWithStaticGenerationBailoutErrorWithDynamicError(route, expression) {
    throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError("Route ".concat(route, ' with `dynamic = "error"` couldn\'t be rendered statically because it used ').concat(expression, ". See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering")), "__NEXT_ERROR_CODE", {
        value: "E543",
        enumerable: false,
        configurable: true
    });
}
function throwForSearchParamsAccessInUseCache(workStore, constructorOpt) {
    var _workStore;
    const error = Object.defineProperty(new Error("Route ".concat(workStore.route, ' used "searchParams" inside "use cache". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await "searchParams" outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache')), "__NEXT_ERROR_CODE", {
        value: "E779",
        enumerable: false,
        configurable: true
    });
    Error.captureStackTrace(error, constructorOpt);
    var _invalidDynamicUsageError;
    (_invalidDynamicUsageError = (_workStore = workStore).invalidDynamicUsageError) !== null && _invalidDynamicUsageError !== void 0 ? _invalidDynamicUsageError : _workStore.invalidDynamicUsageError = error;
    throw error;
}
function isRequestAPICallableInsideAfter() {
    const afterTaskStore = _aftertaskasyncstorageexternal.afterTaskAsyncStorage.getStore();
    return (afterTaskStore == null ? void 0 : afterTaskStore.rootTaskSpawnPhase) === 'action';
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/server/request/search-params.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createPrerenderSearchParamsForClientPage: null,
    createSearchParamsFromClient: null,
    createServerSearchParamsForMetadata: null,
    createServerSearchParamsForServerPage: null,
    makeErroringSearchParamsForUseCache: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createPrerenderSearchParamsForClientPage: function() {
        return createPrerenderSearchParamsForClientPage;
    },
    createSearchParamsFromClient: function() {
        return createSearchParamsFromClient;
    },
    createServerSearchParamsForMetadata: function() {
        return createServerSearchParamsForMetadata;
    },
    createServerSearchParamsForServerPage: function() {
        return createServerSearchParamsForServerPage;
    },
    makeErroringSearchParamsForUseCache: function() {
        return makeErroringSearchParamsForUseCache;
    }
});
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-client] (ecmascript)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-unit-async-storage.external.js [app-client] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)");
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-client] (ecmascript)");
const _creatededupedbycallsiteservererrorlogger = __turbopack_context__.r("[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-client] (ecmascript)");
const _reflectutils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/reflect-utils.js [app-client] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/utils.js [app-client] (ecmascript)");
function createSearchParamsFromClient(underlyingSearchParams, workStore) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                return createStaticPrerenderSearchParams(workStore, workUnitStore);
            case 'prerender-runtime':
                throw Object.defineProperty(new _invarianterror.InvariantError('createSearchParamsFromClient should not be called in a runtime prerender.'), "__NEXT_ERROR_CODE", {
                    value: "E769",
                    enumerable: false,
                    configurable: true
                });
            case 'cache':
            case 'private-cache':
            case 'unstable-cache':
                throw Object.defineProperty(new _invarianterror.InvariantError('createSearchParamsFromClient should not be called in cache contexts.'), "__NEXT_ERROR_CODE", {
                    value: "E739",
                    enumerable: false,
                    configurable: true
                });
            case 'request':
                return createRenderSearchParams(underlyingSearchParams, workStore);
            default:
                workUnitStore;
        }
    }
    (0, _workunitasyncstorageexternal.throwInvariantForMissingStore)();
}
const createServerSearchParamsForMetadata = createServerSearchParamsForServerPage;
function createServerSearchParamsForServerPage(underlyingSearchParams, workStore) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                return createStaticPrerenderSearchParams(workStore, workUnitStore);
            case 'cache':
            case 'private-cache':
            case 'unstable-cache':
                throw Object.defineProperty(new _invarianterror.InvariantError('createServerSearchParamsForServerPage should not be called in cache contexts.'), "__NEXT_ERROR_CODE", {
                    value: "E747",
                    enumerable: false,
                    configurable: true
                });
            case 'prerender-runtime':
                return createRuntimePrerenderSearchParams(underlyingSearchParams, workUnitStore);
            case 'request':
                return createRenderSearchParams(underlyingSearchParams, workStore);
            default:
                workUnitStore;
        }
    }
    (0, _workunitasyncstorageexternal.throwInvariantForMissingStore)();
}
function createPrerenderSearchParamsForClientPage(workStore) {
    if (workStore.forceStatic) {
        // When using forceStatic we override all other logic and always just return an empty
        // dictionary object.
        return Promise.resolve({});
    }
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
                // We're prerendering in a mode that aborts (cacheComponents) and should stall
                // the promise to ensure the RSC side is considered dynamic
                return (0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, '`searchParams`');
            case 'prerender-runtime':
                throw Object.defineProperty(new _invarianterror.InvariantError('createPrerenderSearchParamsForClientPage should not be called in a runtime prerender.'), "__NEXT_ERROR_CODE", {
                    value: "E768",
                    enumerable: false,
                    configurable: true
                });
            case 'cache':
            case 'private-cache':
            case 'unstable-cache':
                throw Object.defineProperty(new _invarianterror.InvariantError('createPrerenderSearchParamsForClientPage should not be called in cache contexts.'), "__NEXT_ERROR_CODE", {
                    value: "E746",
                    enumerable: false,
                    configurable: true
                });
            case 'prerender-ppr':
            case 'prerender-legacy':
            case 'request':
                return Promise.resolve({});
            default:
                workUnitStore;
        }
    }
    (0, _workunitasyncstorageexternal.throwInvariantForMissingStore)();
}
function createStaticPrerenderSearchParams(workStore, prerenderStore) {
    if (workStore.forceStatic) {
        // When using forceStatic we override all other logic and always just return an empty
        // dictionary object.
        return Promise.resolve({});
    }
    switch(prerenderStore.type){
        case 'prerender':
        case 'prerender-client':
            // We are in a cacheComponents (PPR or otherwise) prerender
            return makeHangingSearchParams(workStore, prerenderStore);
        case 'prerender-ppr':
        case 'prerender-legacy':
            // We are in a legacy static generation and need to interrupt the
            // prerender when search params are accessed.
            return makeErroringExoticSearchParams(workStore, prerenderStore);
        default:
            return prerenderStore;
    }
}
function createRuntimePrerenderSearchParams(underlyingSearchParams, workUnitStore) {
    return (0, _dynamicrendering.delayUntilRuntimeStage)(workUnitStore, ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : makeUntrackedExoticSearchParams(underlyingSearchParams));
}
function createRenderSearchParams(underlyingSearchParams, workStore) {
    if (workStore.forceStatic) {
        // When using forceStatic we override all other logic and always just return an empty
        // dictionary object.
        return Promise.resolve({});
    } else {
        if ("TURBOPACK compile-time truthy", 1) {
            // Semantically we only need the dev tracking when running in `next dev`
            // but since you would never use next dev with production NODE_ENV we use this
            // as a proxy so we can statically exclude this code from production builds.
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            return makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, workStore);
        } else //TURBOPACK unreachable
        ;
    }
}
const CachedSearchParams = new WeakMap();
const CachedSearchParamsForUseCache = new WeakMap();
function makeHangingSearchParams(workStore, prerenderStore) {
    const cachedSearchParams = CachedSearchParams.get(prerenderStore);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const promise = (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, workStore.route, '`searchParams`');
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (Object.hasOwn(promise, prop)) {
                // The promise has this property directly. we must return it.
                // We know it isn't a dynamic access because it can only be something
                // that was previously written to the promise and thus not an underlying searchParam value
                return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
            switch(prop){
                case 'then':
                    {
                        const expression = '`await searchParams`, `searchParams.then`, or similar';
                        (0, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                    }
                case 'status':
                    {
                        const expression = '`use(searchParams)`, `searchParams.status`, or similar';
                        (0, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                    }
                default:
                    {
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                    }
            }
        }
    });
    CachedSearchParams.set(prerenderStore, proxiedPromise);
    return proxiedPromise;
}
function makeErroringExoticSearchParams(workStore, prerenderStore) {
    const cachedSearchParams = CachedSearchParams.get(workStore);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const underlyingSearchParams = {};
    // For search params we don't construct a ReactPromise because we want to interrupt
    // rendering on any property access that was not set from outside and so we only want
    // to have properties like value and status if React sets them.
    const promise = Promise.resolve(underlyingSearchParams);
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (Object.hasOwn(promise, prop)) {
                // The promise has this property directly. we must return it.
                // We know it isn't a dynamic access because it can only be something
                // that was previously written to the promise and thus not an underlying searchParam value
                return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
            switch(prop){
                case 'then':
                    {
                        const expression = '`await searchParams`, `searchParams.then`, or similar';
                        if (workStore.dynamicShouldError) {
                            (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);
                        } else if (prerenderStore.type === 'prerender-ppr') {
                            // PPR Prerender (no cacheComponents)
                            (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);
                        } else {
                            // Legacy Prerender
                            (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);
                        }
                        return;
                    }
                case 'status':
                    {
                        const expression = '`use(searchParams)`, `searchParams.status`, or similar';
                        if (workStore.dynamicShouldError) {
                            (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);
                        } else if (prerenderStore.type === 'prerender-ppr') {
                            // PPR Prerender (no cacheComponents)
                            (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);
                        } else {
                            // Legacy Prerender
                            (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);
                        }
                        return;
                    }
                default:
                    {
                        if (typeof prop === 'string' && !_reflectutils.wellKnownProperties.has(prop)) {
                            const expression = (0, _reflectutils.describeStringPropertyAccess)('searchParams', prop);
                            if (workStore.dynamicShouldError) {
                                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);
                            } else if (prerenderStore.type === 'prerender-ppr') {
                                // PPR Prerender (no cacheComponents)
                                (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);
                            } else {
                                // Legacy Prerender
                                (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);
                            }
                        }
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                    }
            }
        },
        has (target, prop) {
            // We don't expect key checking to be used except for testing the existence of
            // searchParams so we make all has tests trigger dynamic. this means that `promise.then`
            // can resolve to the then function on the Promise prototype but 'then' in promise will assume
            // you are testing whether the searchParams has a 'then' property.
            if (typeof prop === 'string') {
                const expression = (0, _reflectutils.describeHasCheckingStringProperty)('searchParams', prop);
                if (workStore.dynamicShouldError) {
                    (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);
                } else if (prerenderStore.type === 'prerender-ppr') {
                    // PPR Prerender (no cacheComponents)
                    (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);
                } else {
                    // Legacy Prerender
                    (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);
                }
                return false;
            }
            return _reflect.ReflectAdapter.has(target, prop);
        },
        ownKeys () {
            const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';
            if (workStore.dynamicShouldError) {
                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);
            } else if (prerenderStore.type === 'prerender-ppr') {
                // PPR Prerender (no cacheComponents)
                (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);
            } else {
                // Legacy Prerender
                (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);
            }
        }
    });
    CachedSearchParams.set(workStore, proxiedPromise);
    return proxiedPromise;
}
function makeErroringSearchParamsForUseCache(workStore) {
    const cachedSearchParams = CachedSearchParamsForUseCache.get(workStore);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const promise = Promise.resolve({});
    const proxiedPromise = new Proxy(promise, {
        get: function get(target, prop, receiver) {
            if (Object.hasOwn(promise, prop)) {
                // The promise has this property directly. we must return it. We know it
                // isn't a dynamic access because it can only be something that was
                // previously written to the promise and thus not an underlying
                // searchParam value
                return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
            if (typeof prop === 'string' && (prop === 'then' || !_reflectutils.wellKnownProperties.has(prop))) {
                (0, _utils.throwForSearchParamsAccessInUseCache)(workStore, get);
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        has: function has(target, prop) {
            // We don't expect key checking to be used except for testing the existence of
            // searchParams so we make all has tests throw an error. this means that `promise.then`
            // can resolve to the then function on the Promise prototype but 'then' in promise will assume
            // you are testing whether the searchParams has a 'then' property.
            if (typeof prop === 'string' && (prop === 'then' || !_reflectutils.wellKnownProperties.has(prop))) {
                (0, _utils.throwForSearchParamsAccessInUseCache)(workStore, has);
            }
            return _reflect.ReflectAdapter.has(target, prop);
        },
        ownKeys: function ownKeys() {
            (0, _utils.throwForSearchParamsAccessInUseCache)(workStore, ownKeys);
        }
    });
    CachedSearchParamsForUseCache.set(workStore, proxiedPromise);
    return proxiedPromise;
}
function makeUntrackedExoticSearchParams(underlyingSearchParams) {
    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    // We don't use makeResolvedReactPromise here because searchParams
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = Promise.resolve(underlyingSearchParams);
    CachedSearchParams.set(underlyingSearchParams, promise);
    Object.keys(underlyingSearchParams).forEach((prop)=>{
        if (!_reflectutils.wellKnownProperties.has(prop)) {
            Object.defineProperty(promise, prop, {
                get () {
                    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
                    if (workUnitStore) {
                        (0, _dynamicrendering.trackDynamicDataInDynamicRender)(workUnitStore);
                    }
                    return underlyingSearchParams[prop];
                },
                set (value) {
                    Object.defineProperty(promise, prop, {
                        value,
                        writable: true,
                        enumerable: true
                    });
                },
                enumerable: true,
                configurable: true
            });
        }
    });
    return promise;
}
function makeUntrackedSearchParams(underlyingSearchParams) {
    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const promise = Promise.resolve(underlyingSearchParams);
    CachedSearchParams.set(underlyingSearchParams, promise);
    return promise;
}
function makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, store) {
    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying
    // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender
    // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking
    // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger
    // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce
    // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.
    let promiseInitialized = false;
    const proxiedUnderlying = new Proxy(underlyingSearchParams, {
        get (target, prop, receiver) {
            if (typeof prop === 'string' && promiseInitialized) {
                if (store.dynamicShouldError) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('searchParams', prop);
                    (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);
                }
                const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
                if (workUnitStore) {
                    (0, _dynamicrendering.trackDynamicDataInDynamicRender)(workUnitStore);
                }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        has (target, prop) {
            if (typeof prop === 'string') {
                if (store.dynamicShouldError) {
                    const expression = (0, _reflectutils.describeHasCheckingStringProperty)('searchParams', prop);
                    (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);
                }
            }
            return Reflect.has(target, prop);
        },
        ownKeys (target) {
            if (store.dynamicShouldError) {
                const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';
                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);
            }
            return Reflect.ownKeys(target);
        }
    });
    // We don't use makeResolvedReactPromise here because searchParams
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = (0, _dynamicrenderingutils.makeDevtoolsIOAwarePromise)(underlyingSearchParams);
    promise.then(()=>{
        promiseInitialized = true;
    });
    Object.keys(underlyingSearchParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
            // These properties cannot be shadowed because they need to be the
            // true underlying value for Promises to work correctly at runtime
            unproxiedProperties.push(prop);
        } else {
            proxiedProperties.add(prop);
            Object.defineProperty(promise, prop, {
                get () {
                    return proxiedUnderlying[prop];
                },
                set (newValue) {
                    Object.defineProperty(promise, prop, {
                        value: newValue,
                        writable: true,
                        enumerable: true
                    });
                },
                enumerable: true,
                configurable: true
            });
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (prop === 'then' && store.dynamicShouldError) {
                const expression = '`searchParams.then`';
                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);
            }
            if (typeof prop === 'string') {
                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('searchParams', prop);
                    syncIODev(store.route, expression);
                }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return Reflect.set(target, prop, value, receiver);
        },
        has (target, prop) {
            if (typeof prop === 'string') {
                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, _reflectutils.describeHasCheckingStringProperty)('searchParams', prop);
                    syncIODev(store.route, expression);
                }
            }
            return Reflect.has(target, prop);
        },
        ownKeys (target) {
            const expression = '`Object.keys(searchParams)` or similar';
            syncIODev(store.route, expression, unproxiedProperties);
            return Reflect.ownKeys(target);
        }
    });
    CachedSearchParams.set(underlyingSearchParams, proxiedPromise);
    return proxiedPromise;
}
// Similar to `makeDynamicallyTrackedExoticSearchParamsWithDevWarnings`, but
// just logging the sync access without actually defining the search params on
// the promise.
function makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams, store) {
    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    const promise = (0, _dynamicrenderingutils.makeDevtoolsIOAwarePromise)(underlyingSearchParams);
    Object.keys(underlyingSearchParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
            // These properties cannot be shadowed because they need to be the
            // true underlying value for Promises to work correctly at runtime
            unproxiedProperties.push(prop);
        } else {
            proxiedProperties.add(prop);
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (typeof prop === 'string') {
                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('searchParams', prop);
                    warnForSyncAccess(store.route, expression);
                }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return Reflect.set(target, prop, value, receiver);
        },
        has (target, prop) {
            if (typeof prop === 'string') {
                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, _reflectutils.describeHasCheckingStringProperty)('searchParams', prop);
                    warnForSyncAccess(store.route, expression);
                }
            }
            return Reflect.has(target, prop);
        },
        ownKeys (target) {
            const expression = '`Object.keys(searchParams)` or similar';
            warnForIncompleteEnumeration(store.route, expression, unproxiedProperties);
            return Reflect.ownKeys(target);
        }
    });
    CachedSearchParams.set(underlyingSearchParams, proxiedPromise);
    return proxiedPromise;
}
function syncIODev(route, expression, missingProperties) {
    // In all cases we warn normally
    if (missingProperties && missingProperties.length > 0) {
        warnForIncompleteEnumeration(route, expression, missingProperties);
    } else {
        warnForSyncAccess(route, expression);
    }
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'request':
                if (workUnitStore.prerenderPhase === true) {
                    // When we're rendering dynamically in dev, we need to advance out of
                    // the Prerender environment when we read Request data synchronously.
                    (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(workUnitStore);
                }
                break;
            case 'prerender':
            case 'prerender-client':
            case 'prerender-runtime':
            case 'prerender-ppr':
            case 'prerender-legacy':
            case 'cache':
            case 'private-cache':
            case 'unstable-cache':
                break;
            default:
                workUnitStore;
        }
    }
}
const warnForSyncAccess = (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createSearchAccessError);
const warnForIncompleteEnumeration = (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createIncompleteEnumerationError);
function createSearchAccessError(route, expression) {
    const prefix = route ? 'Route "'.concat(route, '" ') : 'This route ';
    return Object.defineProperty(new Error("".concat(prefix, "used ").concat(expression, ". ") + "`searchParams` should be awaited before using its properties. " + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis"), "__NEXT_ERROR_CODE", {
        value: "E249",
        enumerable: false,
        configurable: true
    });
}
function createIncompleteEnumerationError(route, expression, missingProperties) {
    const prefix = route ? 'Route "'.concat(route, '" ') : 'This route ';
    return Object.defineProperty(new Error("".concat(prefix, "used ").concat(expression, ". ") + "`searchParams` should be awaited before using its properties. " + "The following properties were not available through enumeration " + "because they conflict with builtin or well-known property names: " + "".concat(describeListOfPropertyNames(missingProperties), ". ") + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis"), "__NEXT_ERROR_CODE", {
        value: "E2",
        enumerable: false,
        configurable: true
    });
}
function describeListOfPropertyNames(properties) {
    switch(properties.length){
        case 0:
            throw Object.defineProperty(new _invarianterror.InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.'), "__NEXT_ERROR_CODE", {
                value: "E531",
                enumerable: false,
                configurable: true
            });
        case 1:
            return "`".concat(properties[0], "`");
        case 2:
            return "`".concat(properties[0], "` and `").concat(properties[1], "`");
        default:
            {
                let description = '';
                for(let i = 0; i < properties.length - 1; i++){
                    description += "`".concat(properties[i], "`, ");
                }
                description += ", and `".concat(properties[properties.length - 1], "`");
                return description;
            }
    }
} //# sourceMappingURL=search-params.js.map
}),
"[project]/node_modules/next/dist/server/app-render/dynamic-access-async-storage-instance.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "dynamicAccessAsyncStorageInstance", {
    enumerable: true,
    get: function() {
        return dynamicAccessAsyncStorageInstance;
    }
});
const _asynclocalstorage = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/async-local-storage.js [app-client] (ecmascript)");
const dynamicAccessAsyncStorageInstance = (0, _asynclocalstorage.createAsyncLocalStorage)(); //# sourceMappingURL=dynamic-access-async-storage-instance.js.map
}),
"[project]/node_modules/next/dist/server/app-render/dynamic-access-async-storage.external.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "dynamicAccessAsyncStorage", {
    enumerable: true,
    get: function() {
        return _dynamicaccessasyncstorageinstance.dynamicAccessAsyncStorageInstance;
    }
});
const _dynamicaccessasyncstorageinstance = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-access-async-storage-instance.js [app-client] (ecmascript)"); //# sourceMappingURL=dynamic-access-async-storage.external.js.map
}),
"[project]/node_modules/next/dist/server/request/params.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createParamsFromClient: null,
    createPrerenderParamsForClientSegment: null,
    createServerParamsForMetadata: null,
    createServerParamsForRoute: null,
    createServerParamsForServerSegment: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createParamsFromClient: function() {
        return createParamsFromClient;
    },
    createPrerenderParamsForClientSegment: function() {
        return createPrerenderParamsForClientSegment;
    },
    createServerParamsForMetadata: function() {
        return createServerParamsForMetadata;
    },
    createServerParamsForRoute: function() {
        return createServerParamsForRoute;
    },
    createServerParamsForServerSegment: function() {
        return createServerParamsForServerSegment;
    }
});
const _workasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)");
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-client] (ecmascript)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-unit-async-storage.external.js [app-client] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)");
const _reflectutils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/reflect-utils.js [app-client] (ecmascript)");
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-client] (ecmascript)");
const _creatededupedbycallsiteservererrorlogger = __turbopack_context__.r("[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-client] (ecmascript)");
const _dynamicaccessasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-access-async-storage.external.js [app-client] (ecmascript)");
function createParamsFromClient(underlyingParams, workStore) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                return createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);
            case 'cache':
            case 'private-cache':
            case 'unstable-cache':
                throw Object.defineProperty(new _invarianterror.InvariantError('createParamsFromClient should not be called in cache contexts.'), "__NEXT_ERROR_CODE", {
                    value: "E736",
                    enumerable: false,
                    configurable: true
                });
            case 'prerender-runtime':
                throw Object.defineProperty(new _invarianterror.InvariantError('createParamsFromClient should not be called in a runtime prerender.'), "__NEXT_ERROR_CODE", {
                    value: "E770",
                    enumerable: false,
                    configurable: true
                });
            case 'request':
                if ("TURBOPACK compile-time truthy", 1) {
                    // Semantically we only need the dev tracking when running in `next dev`
                    // but since you would never use next dev with production NODE_ENV we use this
                    // as a proxy so we can statically exclude this code from production builds.
                    const devFallbackParams = workUnitStore.devFallbackParams;
                    return createRenderParamsInDev(underlyingParams, devFallbackParams, workStore);
                } else //TURBOPACK unreachable
                ;
            default:
                workUnitStore;
        }
    }
    (0, _workunitasyncstorageexternal.throwInvariantForMissingStore)();
}
const createServerParamsForMetadata = createServerParamsForServerSegment;
function createServerParamsForRoute(underlyingParams, workStore) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                return createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);
            case 'cache':
            case 'private-cache':
            case 'unstable-cache':
                throw Object.defineProperty(new _invarianterror.InvariantError('createServerParamsForRoute should not be called in cache contexts.'), "__NEXT_ERROR_CODE", {
                    value: "E738",
                    enumerable: false,
                    configurable: true
                });
            case 'prerender-runtime':
                return createRuntimePrerenderParams(underlyingParams, workUnitStore);
            case 'request':
                if ("TURBOPACK compile-time truthy", 1) {
                    // Semantically we only need the dev tracking when running in `next dev`
                    // but since you would never use next dev with production NODE_ENV we use this
                    // as a proxy so we can statically exclude this code from production builds.
                    const devFallbackParams = workUnitStore.devFallbackParams;
                    return createRenderParamsInDev(underlyingParams, devFallbackParams, workStore);
                } else //TURBOPACK unreachable
                ;
            default:
                workUnitStore;
        }
    }
    (0, _workunitasyncstorageexternal.throwInvariantForMissingStore)();
}
function createServerParamsForServerSegment(underlyingParams, workStore) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                return createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);
            case 'cache':
            case 'private-cache':
            case 'unstable-cache':
                throw Object.defineProperty(new _invarianterror.InvariantError('createServerParamsForServerSegment should not be called in cache contexts.'), "__NEXT_ERROR_CODE", {
                    value: "E743",
                    enumerable: false,
                    configurable: true
                });
            case 'prerender-runtime':
                return createRuntimePrerenderParams(underlyingParams, workUnitStore);
            case 'request':
                if ("TURBOPACK compile-time truthy", 1) {
                    // Semantically we only need the dev tracking when running in `next dev`
                    // but since you would never use next dev with production NODE_ENV we use this
                    // as a proxy so we can statically exclude this code from production builds.
                    const devFallbackParams = workUnitStore.devFallbackParams;
                    return createRenderParamsInDev(underlyingParams, devFallbackParams, workStore);
                } else //TURBOPACK unreachable
                ;
            default:
                workUnitStore;
        }
    }
    (0, _workunitasyncstorageexternal.throwInvariantForMissingStore)();
}
function createPrerenderParamsForClientSegment(underlyingParams) {
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    if (!workStore) {
        throw Object.defineProperty(new _invarianterror.InvariantError('Missing workStore in createPrerenderParamsForClientSegment'), "__NEXT_ERROR_CODE", {
            value: "E773",
            enumerable: false,
            configurable: true
        });
    }
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
                const fallbackParams = workUnitStore.fallbackRouteParams;
                if (fallbackParams) {
                    for(let key in underlyingParams){
                        if (fallbackParams.has(key)) {
                            // This params object has one or more fallback params, so we need
                            // to consider the awaiting of this params object "dynamic". Since
                            // we are in cacheComponents mode we encode this as a promise that never
                            // resolves.
                            return (0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, '`params`');
                        }
                    }
                }
                break;
            case 'cache':
            case 'private-cache':
            case 'unstable-cache':
                throw Object.defineProperty(new _invarianterror.InvariantError('createPrerenderParamsForClientSegment should not be called in cache contexts.'), "__NEXT_ERROR_CODE", {
                    value: "E734",
                    enumerable: false,
                    configurable: true
                });
            case 'prerender-ppr':
            case 'prerender-legacy':
            case 'prerender-runtime':
            case 'request':
                break;
            default:
                workUnitStore;
        }
    }
    // We're prerendering in a mode that does not abort. We resolve the promise without
    // any tracking because we're just transporting a value from server to client where the tracking
    // will be applied.
    return Promise.resolve(underlyingParams);
}
function createStaticPrerenderParams(underlyingParams, workStore, prerenderStore) {
    switch(prerenderStore.type){
        case 'prerender':
        case 'prerender-client':
            {
                const fallbackParams = prerenderStore.fallbackRouteParams;
                if (fallbackParams) {
                    for(const key in underlyingParams){
                        if (fallbackParams.has(key)) {
                            // This params object has one or more fallback params, so we need
                            // to consider the awaiting of this params object "dynamic". Since
                            // we are in cacheComponents mode we encode this as a promise that never
                            // resolves.
                            return makeHangingParams(underlyingParams, workStore, prerenderStore);
                        }
                    }
                }
                break;
            }
        case 'prerender-ppr':
            {
                const fallbackParams = prerenderStore.fallbackRouteParams;
                if (fallbackParams) {
                    for(const key in underlyingParams){
                        if (fallbackParams.has(key)) {
                            return makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore);
                        }
                    }
                }
                break;
            }
        case 'prerender-legacy':
            break;
        default:
            prerenderStore;
    }
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        return makeUntrackedExoticParams(underlyingParams);
    }
}
function createRuntimePrerenderParams(underlyingParams, workUnitStore) {
    return (0, _dynamicrendering.delayUntilRuntimeStage)(workUnitStore, ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : makeUntrackedExoticParams(underlyingParams));
}
function createRenderParamsInProd(underlyingParams) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return makeUntrackedExoticParams(underlyingParams);
}
function createRenderParamsInDev(underlyingParams, devFallbackParams, workStore) {
    let hasFallbackParams = false;
    if (devFallbackParams) {
        for(let key in underlyingParams){
            if (devFallbackParams.has(key)) {
                hasFallbackParams = true;
                break;
            }
        }
    }
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, hasFallbackParams, workStore);
}
const CachedParams = new WeakMap();
const fallbackParamsProxyHandler = {
    get: function get(target, prop, receiver) {
        if (prop === 'then' || prop === 'catch' || prop === 'finally') {
            const originalMethod = _reflect.ReflectAdapter.get(target, prop, receiver);
            return ({
                [prop]: function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    const store = _dynamicaccessasyncstorageexternal.dynamicAccessAsyncStorage.getStore();
                    if (store) {
                        store.abortController.abort(Object.defineProperty(new Error("Accessed fallback `params` during prerendering."), "__NEXT_ERROR_CODE", {
                            value: "E691",
                            enumerable: false,
                            configurable: true
                        }));
                    }
                    return new Proxy(originalMethod.apply(target, args), fallbackParamsProxyHandler);
                }
            })[prop];
        }
        return _reflect.ReflectAdapter.get(target, prop, receiver);
    }
};
function makeHangingParams(underlyingParams, workStore, prerenderStore) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    const promise = new Proxy((0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, workStore.route, '`params`'), fallbackParamsProxyHandler);
    CachedParams.set(underlyingParams, promise);
    return promise;
}
function makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    const augmentedUnderlying = {
        ...underlyingParams
    };
    // We don't use makeResolvedReactPromise here because params
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = Promise.resolve(augmentedUnderlying);
    CachedParams.set(underlyingParams, promise);
    Object.keys(underlyingParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
        // These properties cannot be shadowed because they need to be the
        // true underlying value for Promises to work correctly at runtime
        } else {
            if (fallbackParams.has(prop)) {
                Object.defineProperty(augmentedUnderlying, prop, {
                    get () {
                        const expression = (0, _reflectutils.describeStringPropertyAccess)('params', prop);
                        // In most dynamic APIs we also throw if `dynamic = "error"` however
                        // for params is only dynamic when we're generating a fallback shell
                        // and even when `dynamic = "error"` we still support generating dynamic
                        // fallback shells
                        // TODO remove this comment when cacheComponents is the default since there
                        // will be no `dynamic = "error"`
                        if (prerenderStore.type === 'prerender-ppr') {
                            // PPR Prerender (no cacheComponents)
                            (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);
                        } else {
                            // Legacy Prerender
                            (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);
                        }
                    },
                    enumerable: true
                });
                Object.defineProperty(promise, prop, {
                    get () {
                        const expression = (0, _reflectutils.describeStringPropertyAccess)('params', prop);
                        // In most dynamic APIs we also throw if `dynamic = "error"` however
                        // for params is only dynamic when we're generating a fallback shell
                        // and even when `dynamic = "error"` we still support generating dynamic
                        // fallback shells
                        // TODO remove this comment when cacheComponents is the default since there
                        // will be no `dynamic = "error"`
                        if (prerenderStore.type === 'prerender-ppr') {
                            // PPR Prerender (no cacheComponents)
                            (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);
                        } else {
                            // Legacy Prerender
                            (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);
                        }
                    },
                    set (newValue) {
                        Object.defineProperty(promise, prop, {
                            value: newValue,
                            writable: true,
                            enumerable: true
                        });
                    },
                    enumerable: true,
                    configurable: true
                });
            } else {
                ;
                promise[prop] = underlyingParams[prop];
            }
        }
    });
    return promise;
}
function makeUntrackedExoticParams(underlyingParams) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    // We don't use makeResolvedReactPromise here because params
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = Promise.resolve(underlyingParams);
    CachedParams.set(underlyingParams, promise);
    Object.keys(underlyingParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
        // These properties cannot be shadowed because they need to be the
        // true underlying value for Promises to work correctly at runtime
        } else {
            ;
            promise[prop] = underlyingParams[prop];
        }
    });
    return promise;
}
function makeUntrackedParams(underlyingParams) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    const promise = Promise.resolve(underlyingParams);
    CachedParams.set(underlyingParams, promise);
    return promise;
}
function makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, hasFallbackParams, store) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    // We don't use makeResolvedReactPromise here because params
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = hasFallbackParams ? (0, _dynamicrenderingutils.makeDevtoolsIOAwarePromise)(underlyingParams) : Promise.resolve(underlyingParams);
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    Object.keys(underlyingParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
            // These properties cannot be shadowed because they need to be the
            // true underlying value for Promises to work correctly at runtime
            unproxiedProperties.push(prop);
        } else {
            proxiedProperties.add(prop);
            promise[prop] = underlyingParams[prop];
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (typeof prop === 'string') {
                if (proxiedProperties.has(prop)) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('params', prop);
                    syncIODev(store.route, expression);
                }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return _reflect.ReflectAdapter.set(target, prop, value, receiver);
        },
        ownKeys (target) {
            const expression = '`...params` or similar expression';
            syncIODev(store.route, expression, unproxiedProperties);
            return Reflect.ownKeys(target);
        }
    });
    CachedParams.set(underlyingParams, proxiedPromise);
    return proxiedPromise;
}
// Similar to `makeDynamicallyTrackedExoticParamsWithDevWarnings`, but just
// logging the sync access without actually defining the params on the promise.
function makeDynamicallyTrackedParamsWithDevWarnings(underlyingParams, hasFallbackParams, store) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    // We don't use makeResolvedReactPromise here because params
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = hasFallbackParams ? (0, _dynamicrenderingutils.makeDevtoolsIOAwarePromise)(underlyingParams) : Promise.resolve(underlyingParams);
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    Object.keys(underlyingParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
            // These properties cannot be shadowed because they need to be the
            // true underlying value for Promises to work correctly at runtime
            unproxiedProperties.push(prop);
        } else {
            proxiedProperties.add(prop);
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (typeof prop === 'string') {
                if (proxiedProperties.has(prop)) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('params', prop);
                    warnForSyncAccess(store.route, expression);
                }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return _reflect.ReflectAdapter.set(target, prop, value, receiver);
        },
        ownKeys (target) {
            const expression = '`...params` or similar expression';
            warnForIncompleteEnumeration(store.route, expression, unproxiedProperties);
            return Reflect.ownKeys(target);
        }
    });
    CachedParams.set(underlyingParams, proxiedPromise);
    return proxiedPromise;
}
function syncIODev(route, expression, missingProperties) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'request':
                if (workUnitStore.prerenderPhase === true) {
                    // When we're rendering dynamically in dev, we need to advance out of
                    // the Prerender environment when we read Request data synchronously.
                    (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(workUnitStore);
                }
                break;
            case 'prerender':
            case 'prerender-client':
            case 'prerender-runtime':
            case 'prerender-ppr':
            case 'prerender-legacy':
            case 'cache':
            case 'private-cache':
            case 'unstable-cache':
                break;
            default:
                workUnitStore;
        }
    }
    // In all cases we warn normally
    if (missingProperties && missingProperties.length > 0) {
        warnForIncompleteEnumeration(route, expression, missingProperties);
    } else {
        warnForSyncAccess(route, expression);
    }
}
const warnForSyncAccess = (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createParamsAccessError);
const warnForIncompleteEnumeration = (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createIncompleteEnumerationError);
function createParamsAccessError(route, expression) {
    const prefix = route ? 'Route "'.concat(route, '" ') : 'This route ';
    return Object.defineProperty(new Error("".concat(prefix, "used ").concat(expression, ". ") + "`params` should be awaited before using its properties. " + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis"), "__NEXT_ERROR_CODE", {
        value: "E307",
        enumerable: false,
        configurable: true
    });
}
function createIncompleteEnumerationError(route, expression, missingProperties) {
    const prefix = route ? 'Route "'.concat(route, '" ') : 'This route ';
    return Object.defineProperty(new Error("".concat(prefix, "used ").concat(expression, ". ") + "`params` should be awaited before using its properties. " + "The following properties were not available through enumeration " + "because they conflict with builtin property names: " + "".concat(describeListOfPropertyNames(missingProperties), ". ") + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis"), "__NEXT_ERROR_CODE", {
        value: "E482",
        enumerable: false,
        configurable: true
    });
}
function describeListOfPropertyNames(properties) {
    switch(properties.length){
        case 0:
            throw Object.defineProperty(new _invarianterror.InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.'), "__NEXT_ERROR_CODE", {
                value: "E531",
                enumerable: false,
                configurable: true
            });
        case 1:
            return "`".concat(properties[0], "`");
        case 2:
            return "`".concat(properties[0], "` and `").concat(properties[1], "`");
        default:
            {
                let description = '';
                for(let i = 0; i < properties.length - 1; i++){
                    description += "`".concat(properties[i], "`, ");
                }
                description += ", and `".concat(properties[properties.length - 1], "`");
                return description;
            }
    }
} //# sourceMappingURL=params.js.map
}),
"[project]/node_modules/next/dist/client/components/client-page.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ClientPageRoot", {
    enumerable: true,
    get: function() {
        return ClientPageRoot;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)");
function ClientPageRoot(param) {
    let { Component, searchParams, params, promises } = param;
    if (typeof window === 'undefined') {
        const { workAsyncStorage } = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)");
        let clientSearchParams;
        let clientParams;
        // We are going to instrument the searchParams prop with tracking for the
        // appropriate context. We wrap differently in prerendering vs rendering
        const store = workAsyncStorage.getStore();
        if (!store) {
            throw Object.defineProperty(new _invarianterror.InvariantError('Expected workStore to exist when handling searchParams in a client Page.'), "__NEXT_ERROR_CODE", {
                value: "E564",
                enumerable: false,
                configurable: true
            });
        }
        const { createSearchParamsFromClient } = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/search-params.js [app-client] (ecmascript)");
        clientSearchParams = createSearchParamsFromClient(searchParams, store);
        const { createParamsFromClient } = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/params.js [app-client] (ecmascript)");
        clientParams = createParamsFromClient(params, store);
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {
            params: clientParams,
            searchParams: clientSearchParams
        });
    } else {
        const { createRenderSearchParamsFromClient } = __turbopack_context__.r("[project]/node_modules/next/dist/client/request/search-params.browser.js [app-client] (ecmascript)");
        const clientSearchParams = createRenderSearchParamsFromClient(searchParams);
        const { createRenderParamsFromClient } = __turbopack_context__.r("[project]/node_modules/next/dist/client/request/params.browser.js [app-client] (ecmascript)");
        const clientParams = createRenderParamsFromClient(params);
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {
            params: clientParams,
            searchParams: clientSearchParams
        });
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=client-page.js.map
}),
"[project]/node_modules/next/dist/client/components/client-segment.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ClientSegmentRoot", {
    enumerable: true,
    get: function() {
        return ClientSegmentRoot;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)");
function ClientSegmentRoot(param) {
    let { Component, slots, params, promise } = param;
    if (typeof window === 'undefined') {
        const { workAsyncStorage } = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)");
        let clientParams;
        // We are going to instrument the searchParams prop with tracking for the
        // appropriate context. We wrap differently in prerendering vs rendering
        const store = workAsyncStorage.getStore();
        if (!store) {
            throw Object.defineProperty(new _invarianterror.InvariantError('Expected workStore to exist when handling params in a client segment such as a Layout or Template.'), "__NEXT_ERROR_CODE", {
                value: "E600",
                enumerable: false,
                configurable: true
            });
        }
        const { createParamsFromClient } = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/params.js [app-client] (ecmascript)");
        clientParams = createParamsFromClient(params, store);
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {
            ...slots,
            params: clientParams
        });
    } else {
        const { createRenderParamsFromClient } = __turbopack_context__.r("[project]/node_modules/next/dist/client/request/params.browser.js [app-client] (ecmascript)");
        const clientParams = createRenderParamsFromClient(params);
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {
            ...slots,
            params: clientParams
        });
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=client-segment.js.map
}),
"[project]/node_modules/next/dist/lib/metadata/generate/icon-mark.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "IconMark", {
    enumerable: true,
    get: function() {
        return IconMark;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const IconMark = ()=>{
    if (typeof window !== 'undefined') {
        return null;
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
        name: "\xabnxt-icon\xbb"
    });
}; //# sourceMappingURL=icon-mark.js.map
}),
"[project]/node_modules/next/dist/client/components/metadata/async-metadata.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AsyncMetadataOutlet", {
    enumerable: true,
    get: function() {
        return AsyncMetadataOutlet;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
function MetadataOutlet(param) {
    let { promise } = param;
    const { error, digest } = (0, _react.use)(promise);
    if (error) {
        if (digest) {
            // The error will lose its original digest after passing from server layer to client layer
            // We recover the digest property here to override the React created one if original digest exists.
            ;
            error.digest = digest;
        }
        throw error;
    }
    return null;
}
function AsyncMetadataOutlet(param) {
    let { promise } = param;
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {
        fallback: null,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(MetadataOutlet, {
            promise: promise
        })
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=async-metadata.js.map
}),
]);

//# sourceMappingURL=node_modules_0edbd54f._.js.map